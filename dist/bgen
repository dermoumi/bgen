#!/usr/bin/env bash

# BGEN__SHEBANG_REMOVED

set -o errexit -o errtrace -o pipefail -o nounset

LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
NO_COLOR="${NO_COLOR:-}"


# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/barg/lib/barg.sh
# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/vars.sh
# BGEN__SHEBANG_REMOVED

# Check if the passed variable(s) is declared
# @param variable_name:  Name of variable to check
butl.is_declared() {
    [[ "$(declare -p "$1" 2>/dev/null)" =~ ^"declare -a " ]] || eval "[[ \${$*+x} ]]"
}

# Sets an array by name
# @param variable_name:  Name of the variable
# @param value:  Value of the variable
butl.set_var() {
    # shellcheck disable=SC2059
    printf -v "$1" -- "$2"
}

# Check if value is false
butl.is_false() {
    if ((BASH_VERSINFO[0] < 4)); then
        local value
        value=$(tr '[:upper:]' '[:lower:]' <<<"$1")
    else
        local value=${1,,}
    fi

    [[ "$value" =~ ^(0|f|n|false|off|no)?$ ]]
}

# Check if value is true
butl.is_true() {
    ! butl.is_false "$@"
}
# BGEN__END /home/sdrm/projects/butl/lib/butl/vars.sh
# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/arrays.sh
# BGEN__SHEBANG_REMOVED

# Checks if a variable is declared and is an array
# @param  array_name:  Array to check
butl.is_array() {
    [[ "$(declare -p "$1" 2>/dev/null)" =~ ^"declare -a " ]]
}

# Sets an a array by name
# @param  array_name:  Name of the array
# @param  args...:  Values of the array
butl.set_array() {
    local array_name=$1
    shift

    if (($#)); then
        eval "$array_name=($(printf '%q ' "$@"))"
    else
        eval "$array_name=()"
    fi
}

# Copies an array to another by name
# @param source:  Array to copy from
# @param target:  Array to copy to
# @returns 1 if source
butl.copy_array() {
    if ! butl.is_array "$1"; then
        return 1
    elif eval "((\${#${1}[@]} == 0))"; then
        butl.set_array "$2"
    else
        eval "$2=( \"\${""$1""[@]}\" )"
    fi
}

# Copies an associative array to another by name
# @param source:  Array to copy from
# @param target:  Array to copy to
butl.copy_associative_array() {
    local declare_statement
    declare_statement=$(declare -p "$1" 2>/dev/null)

    if ! [[ "$declare_statement" =~ ^"declare -a " ]]; then
        return 1
    elif eval "((\${#${1}[@]} == 0))"; then
        eval "$2=()"
    else
        if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4))); then
            # workaround bash <4.4 quoting the content of the variables in declare's output
            local __butl_affect_target="'$2=" # will fail if $1 == "__butl_affect_target", but what are the odds

            # also these versions concat array elements instead of replacing them
            # so we unset existing values before setting new ones
            eval "$(eval "echo ${declare_statement/declare -a $1=\'/$__butl_affect_target}")"
        else
            eval "${declare_statement/declare -a $1=/$2=}"
        fi
    fi
}

# Finds the index of an element amongs others
# @param target:       Element to find
# @param args...:      Items to search through
# @sets  array_index:  Index of the item in the array
# @returns  0 if the item is found, 1 if not
butl.index_of() {
    local target=$1
    shift

    local i=0
    while (($#)); do
        if [[ "$1" == "$target" ]]; then
            if declare -p array_index >/dev/null 2>/dev/null; then
                array_index=$i
            fi

            return 0
        fi

        i=$((i + 1))
        shift
    done

    return 1
}

# Joins arguments by a custom delimiter
# @param delimiter:  Which delimiter to use
# @param args...:  Items to join
butl.join_by() {
    local delimiter=$1
    if (($# <= 1)); then
        return 0
    fi

    local first=$2
    shift 2

    printf %s "$first" "${@/#/$delimiter}"
}

# Splits a multiline string into an array
# @param array_name:  Array to copy to
# @param args...?: Items to parse. Falls back to stdin if no arguments are found
butl.split_lines() {
    local array_name=$1
    shift

    local lines=()

    if (($#)); then
        local original_IFS=$IFS
        IFS=$'\n'

        # shellcheck disable=SC2068
        for line in $@; do
            lines+=("$line")
        done

        IFS=$original_IFS
    else
        while read -r line; do
            lines+=("$line")
        done
    fi

    butl.copy_array lines "$array_name"
}
# BGEN__END /home/sdrm/projects/butl/lib/butl/arrays.sh
# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/ansi.sh
# BGEN__SHEBANG_REMOVED

__butl.init_ansi_vars() {
    # Colors o/
    if ((${NO_COLOR:-})); then
        export BUTL_ANSI_RESET=

        export BUTL_ANSI_BOLD=
        export BUTL_ANSI_DIM=
        export BUTL_ANSI_UNDERLINE=
        export BUTL_ANSI_BLINK=
        export BUTL_ANSI_INVERT=
        export BUTL_ANSI_HIDDEN=

        export BUTL_ANSI_RESET_BOLD=
        export BUTL_ANSI_RESET_DIM=
        export BUTL_ANSI_RESET_UNDERLINE=
        export BUTL_ANSI_RESET_BLINK=
        export BUTL_ANSI_RESET_INVERT=
        export BUTL_ANSI_RESET_HIDDEN=

        export BUTL_ANSI_DEFAULT=

        export BUTL_ANSI_BLACK=
        export BUTL_ANSI_RED=
        export BUTL_ANSI_GREEN=
        export BUTL_ANSI_YELLOW=
        export BUTL_ANSI_BLUE=
        export BUTL_ANSI_MAGENTA=
        export BUTL_ANSI_CYAN=
        export BUTL_ANSI_WHITE=

        export BUTL_ANSI_BRBLACK=
        export BUTL_ANSI_BRRED=
        export BUTL_ANSI_BRGREEN=
        export BUTL_ANSI_BRYELLOW=
        export BUTL_ANSI_BRBLUE=
        export BUTL_ANSI_BRMAGENTA=
        export BUTL_ANSI_BRCYAN=
        export BUTL_ANSI_BRWHITE=

        export BUTL_ANSI_BG_DEFAULT=

        export BUTL_ANSI_BG_BLACK=
        export BUTL_ANSI_BG_RED=
        export BUTL_ANSI_BG_GREEN=
        export BUTL_ANSI_BG_YELLOW=
        export BUTL_ANSI_BG_BLUE=
        export BUTL_ANSI_BG_MAGENTA=
        export BUTL_ANSI_BG_CYAN=
        export BUTL_ANSI_BG_WHITE=

        export BUTL_ANSI_BG_BRBLACK=
        export BUTL_ANSI_BG_BRRED=
        export BUTL_ANSI_BG_BRGREEN=
        export BUTL_ANSI_BG_BRYELLOW=
        export BUTL_ANSI_BG_BRBLUE=
        export BUTL_ANSI_BG_BRMAGENTA=
        export BUTL_ANSI_BG_BRCYAN=
        export BUTL_ANSI_BG_BRWHITE=
    else
        export BUTL_ANSI_RESET="\e[0m"

        export BUTL_ANSI_BOLD="\e[1m"
        export BUTL_ANSI_DIM="\e[2m"
        export BUTL_ANSI_UNDERLINE="\e[4m"
        export BUTL_ANSI_BLINK="\e[5m"
        export BUTL_ANSI_INVERT="\e[7m"
        export BUTL_ANSI_HIDDEN="\e[8m"

        export BUTL_ANSI_RESET_BOLD="\e[21m"
        export BUTL_ANSI_RESET_DIM="\e[22m"
        export BUTL_ANSI_RESET_UNDERLINE="\e[24m"
        export BUTL_ANSI_RESET_BLINK="\e[25m"
        export BUTL_ANSI_RESET_INVERT="\e[27m"
        export BUTL_ANSI_RESET_HIDDEN="\e[28m"

        export BUTL_ANSI_DEFAULT="\e[39m"

        export BUTL_ANSI_BLACK="\e[30m"
        export BUTL_ANSI_RED="\e[31m"
        export BUTL_ANSI_GREEN="\e[32m"
        export BUTL_ANSI_YELLOW="\e[33m"
        export BUTL_ANSI_BLUE="\e[34m"
        export BUTL_ANSI_MAGENTA="\e[35m"
        export BUTL_ANSI_CYAN="\e[36m"
        export BUTL_ANSI_WHITE="\e[37m"

        export BUTL_ANSI_BRBLACK="\e[90m"
        export BUTL_ANSI_BRRED="\e[91m"
        export BUTL_ANSI_BRGREEN="\e[92m"
        export BUTL_ANSI_BRYELLOW="\e[93m"
        export BUTL_ANSI_BRBLUE="\e[94m"
        export BUTL_ANSI_BRMAGENTA="\e[95m"
        export BUTL_ANSI_BRCYAN="\e[96m"
        export BUTL_ANSI_BRWHITE="\e[97m"

        export BUTL_ANSI_BG_BLACK="\e[40m"
        export BUTL_ANSI_BG_RED="\e[41m"
        export BUTL_ANSI_BG_GREEN="\e[42m"
        export BUTL_ANSI_BG_YELLOW="\e[43m"
        export BUTL_ANSI_BG_BLUE="\e[44m"
        export BUTL_ANSI_BG_MAGENTA="\e[45m"
        export BUTL_ANSI_BG_CYAN="\e[46m"
        export BUTL_ANSI_BG_WHITE="\e[47m"

        export BUTL_ANSI_BG_BRBLACK="\e[100m"
        export BUTL_ANSI_BG_BRRED="\e[101m"
        export BUTL_ANSI_BG_BRGREEN="\e[102m"
        export BUTL_ANSI_BG_BRYELLOW="\e[103m"
        export BUTL_ANSI_BG_BRBLUE="\e[104m"
        export BUTL_ANSI_BG_BRMAGENTA="\e[105m"
        export BUTL_ANSI_BG_BRCYAN="\e[106m"
        export BUTL_ANSI_BG_BRWHITE="\e[107m"
    fi
}
__butl.init_ansi_vars
# BGEN__END /home/sdrm/projects/butl/lib/butl/ansi.sh
# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/log.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/butl/lib/butl/ansi.sh

__butl.init_log_vars() {
    : "${BUTL_STYLE_EMERGENCY:="${BUTL_ANSI_BOLD}${BUTL_ANSI_BG_RED}${BUTL_ANSI_BRWHITE}"}"
    : "${BUTL_STYLE_ALERT:="${BUTL_ANSI_BOLD}${BUTL_ANSI_BG_RED}${BUTL_ANSI_BLACK}"}"
    : "${BUTL_STYLE_CRITICAL:="${BUTL_ANSI_BOLD}${BUTL_ANSI_RED}"}"
    : "${BUTL_STYLE_ERROR:="${BUTL_ANSI_RED}"}"
    : "${BUTL_STYLE_PRIMARY:="${BUTL_ANSI_BOLD}${BUTL_ANSI_BRCYAN}"}"
    : "${BUTL_STYLE_WARNING:="${BUTL_ANSI_YELLOW}"}"
    : "${BUTL_STYLE_SECONDARY:="${BUTL_ANSI_BOLD}${BUTL_ANSI_BRYELLOW}"}"
    : "${BUTL_STYLE_NOTICE:="${BUTL_ANSI_GREEN}"}"
    : "${BUTL_STYLE_INFO:="${BUTL_ANSI_DEFAULT}"}"
    : "${BUTL_STYLE_DEBUG:="${BUTL_ANSI_BRBLACK}"}"

    if [[ ! "${LOG_LEVEL:-}" ]]; then
        if [[ "${LOGLEVEL:-}" ]]; then
            export LOG_LEVEL=$LOGLEVEL
        elif ((${VERBOSE:-})); then
            export LOG_LEVEL=7
        else
            export LOG_LEVEL=6
        fi
    fi
}
__butl.init_log_vars

# Prints stylized text
# @param style:  Style to use
# @param message...:  Text to echo
butl.echo_stylized() {
    local style=$1
    shift
    printf -- '%b\n' "${style}${*//\\e\[0m/$BUTL_ANSI_RESET$style}${BUTL_ANSI_RESET}"
}

# Prints emergency message
# @param message....: Message to print
butl.log_emergency() {
    butl.echo_stylized "$BUTL_STYLE_EMERGENCY" "$@" >&2
}

# Prints alert message when LOG_LEVEL >= 1
# @param message....: Message to print
butl.log_alert() {
    if ((LOG_LEVEL >= 1)); then
        butl.echo_stylized "$BUTL_STYLE_ALERT" "$@" >&2
    fi
}

# Prints critical message when LOG_LEVEL >= 2
# @param message....: Message to print
butl.log_critical() {
    if ((LOG_LEVEL >= 2)); then
        butl.echo_stylized "$BUTL_STYLE_CRITICAL" "$@" >&2
    fi
}

# Prints error message when LOG_LEVEL >= 3
# @param message....: Message to print
butl.log_error() {
    if ((LOG_LEVEL >= 3)); then
        butl.echo_stylized "$BUTL_STYLE_ERROR" "$@" >&2
    fi
}

# Prints primary message when LOG_LEVEL >= 4
# @param message....: Message to print
butl.log_primary() {
    if ((LOG_LEVEL >= 4)); then
        butl.echo_stylized "$BUTL_STYLE_PRIMARY" "$@" >&2
    fi
}

# Prints warning message when LOG_LEVEL >= 4
# @param message....: Message to print
butl.log_warning() {
    if ((LOG_LEVEL >= 4)); then
        butl.echo_stylized "$BUTL_STYLE_WARNING" "$@" >&2
    fi
}

# Prints secondary message when LOG_LEVEL >= 5
# @param message....: Message to print
butl.log_secondary() {
    if ((LOG_LEVEL >= 5)); then
        butl.echo_stylized "$BUTL_STYLE_SECONDARY" "$@" >&2
    fi
}

# Prints notice message when LOG_LEVEL >= 5
# @param message....: Message to print
butl.log_notice() {
    if ((LOG_LEVEL >= 5)); then
        butl.echo_stylized "$BUTL_STYLE_NOTICE" "$@" >&2
    fi
}

# Prints info message when LOG_LEVEL >= j6
# @param message....: Message to print
butl.log_info() {
    if ((LOG_LEVEL >= 6)); then
        butl.echo_stylized "$BUTL_STYLE_INFO" "$@" >&2
    fi
}

# Prints debug message when LOG_LEVEL >= 7 (or if VERBOSE is set)
# @param message....: Message to print
butl.log_debug() {
    if ((LOG_LEVEL >= 7)); then
        butl.echo_stylized "$BUTL_STYLE_DEBUG" "$@" >&2
    fi
}

# Prints an error and returns and exit code
# @param message:  Message text
# @param exit_code?:  Code to return, defaults to 1
butl.fail() {
    butl.log_error "$1"
    return "${2:-1}"
}

# Prints a critical message and exits program with an exist code
# @param message:  Message text
# @param exit_code?:  Code to return, defaults to 1
butl.die() {
    butl.log_critical "$1"
    exit "${2:-1}"
}
# BGEN__END /home/sdrm/projects/butl/lib/butl/log.sh

# BGEN__BEGIN /home/sdrm/projects/barg/lib/barg/_parse.sh
# BGEN__SHEBANG_REMOVED

# Parses arguments looking for a subcommand
# @param        args...         the arguments to parse
# @required_var subcommand      will be set to the called subcommand
# @required_var subcommand_args will be set to an array of the args that came after the subcommand
# @optional_var global_args     will be set to an array of the args that came before the subcommand
barg.parse() {
    # add the help subcommand if there are other subcommands
    if ! ((${__barg_disable_help:-})); then
        if butl.is_array __barg_subcommands && (("${#__barg_subcommands[@]}")); then
            barg.subcommand help barg.print_usage \
                "Prints this message or the help of the given subcommand"
        fi

        if ! butl.is_declared barg_help; then
            local barg_help=
        fi

        if __barg_has_flags; then
            barg.arg barg_help --short=h --long=help --desc "Prints help information"
        else
            barg.arg barg_help --short=h --long=help --desc "Prints help information" --hidden
        fi
    fi

    butl.is_array __barg_subcommands || __barg_subcommands=()
    butl.is_array __barg_options || __barg_options=()
    butl.is_array __barg_flags || __barg_flags=()
    # shellcheck disable=SC2034 # TODO: Implement arg parsing
    butl.is_array __barg_args || __barg_args=()

    local catchall_array=()
    local process_args_only=0
    local next_arg_index=0

    # Variable to track whether or not the checks were failed
    local failed=0

    # Reset set flags for options
    for option in "${__barg_options[@]-}"; do
        if [[ ! "$option" ]]; then
            continue
        fi

        butl.set_var "__barg_option_${option}_set" 0
    done

    # Reset filled flags for normal arguments
    for arg in "${__barg_args[@]-}"; do
        if [[ ! "$arg" ]]; then
            continue
        fi

        butl.set_var "__barg_arg_${arg}_filled" 0
    done

    # Parse the rest of the arguments
    while (($#)); do
        local arg="$1"
        shift

        local processed_arg=
        if ! ((process_args_only)); then
            if [[ "$arg" == "--" ]]; then
                process_args_only=1
                continue
            fi

            # Check if there's a subcommand
            if [[ "$arg" && " ${__barg_subcommands[*]-} " == *" $arg "* ]]; then
                local var_subcommand_func="__barg_subcommand_${arg//[-]/_}_func"

                if ! butl.is_declared subcommand; then
                    local subcommand=
                fi

                if ! butl.is_declared subcommand_args; then
                    local subcommand_args=()
                fi

                if (($#)); then
                    subcommand="${!var_subcommand_func}"
                    subcommand_args=("$@")
                else
                    subcommand="${!var_subcommand_func}"
                    subcommand_args=()
                fi

                # run help command in this context to access other barg variables
                if [[ "$arg" == "help" ]]; then
                    "$subcommand" "${subcommand_args[@]}"

                    if butl.is_declared should_exit; then
                        butl.set_var should_exit 1
                        return 0
                    else
                        exit 0
                    fi
                fi

                __barg_postprocess_options
                __barg_postprocess_flags
                __barg_postprocess_args
                barg.reset

                return 0
            fi

            # Check options
            for option in "${__barg_options[@]-}"; do
                local shift_count=0

                if [[ "$arg" == --* ]]; then
                    local var_option_long="__barg_option_${option}_long"
                    local option_long="${!var_option_long:-}"
                    if [[ ! "$option_long" ]]; then
                        continue
                    fi

                    if [[ "$arg" == --"$option_long" ]]; then
                        local option_arg="--$option_long"
                        __barg_parse_option "$@"
                        shift "$shift_count"
                    elif [[ "$arg" == --"$option_long"=* ]]; then
                        local param=${arg#--"$option_long"=}
                        local option_arg="--$option_long=$param"
                        __barg_parse_option "$param"
                    fi
                elif [[ "$arg" == -* ]]; then
                    local var_option_short="__barg_option_${option}_short"
                    local option_short="${!var_option_short:-}"
                    if [[ ! "$option_short" ]]; then
                        continue
                    fi

                    if [[ "$arg" == -*"$option_short" ]]; then
                        local option_arg="-$option_short"
                        __barg_parse_option "$@"
                        shift "$shift_count"
                    elif [[ "$arg" == -*"$option_short"=* ]]; then
                        local param=${arg#-*"$option_short"=}
                        local option_arg="-$option_short=$param"
                        __barg_parse_option "$param"
                    fi
                fi

                if ((processed_arg)); then
                    break
                fi
            done

            if ((processed_arg)); then
                continue
            fi

            # Check flags
            for flag in "${__barg_flags[@]-}"; do
                if [[ "$arg" == --* ]]; then
                    local var_flag_long="__barg_flag_${flag}_long"
                    local flag_long="${!var_flag_long:-}"
                    if [[ ! "$flag_long" ]]; then
                        continue
                    fi

                    if [[ "$arg" == "--$flag_long" ]]; then
                        local flag_arg="--$flag_long"
                        __barg_parse_flag
                    fi
                elif [[ "$arg" == -* ]]; then
                    local var_flag_short="__barg_flag_${flag}_short"
                    local flag_short="${!var_flag_short:-}"
                    if [[ ! "$flag_short" ]]; then
                        continue
                    fi

                    if [[ "$arg" == -*"$flag_short"* ]]; then
                        local flag_arg="-$flag_short"
                        __barg_parse_flag
                    fi
                fi

                if ((processed_arg)); then
                    break
                fi
            done

            if ((processed_arg)); then
                continue
            fi
        fi

        if ((next_arg_index < ${#__barg_args[@]})); then
            local arg_name="${__barg_args[$next_arg_index]}"
            if [[ "${__barg_catchall_arg:-}" == "$arg_name" ]]; then
                next_arg_index=$((next_arg_index + 1))
            fi
        fi

        if ((next_arg_index < ${#__barg_args[@]})); then
            local arg_name=${__barg_args[$next_arg_index]}

            local process_arg=1
            if [[ "$arg" == -?* ]]; then
                local var_arg_allow_dash="__barg_arg_${arg_name}_allow_dash"
                local arg_allow_dash=${!var_arg_allow_dash:-}

                if ! ((arg_allow_dash)); then
                    process_arg=0
                fi
            fi

            if ((process_arg)); then
                local arg_values=()
                butl.copy_array "__barg_arg_${arg_name}_values" arg_values

                if ((${#arg_values[@]} <= 1)); then
                    if butl.is_declared "$arg_name"; then
                        butl.set_var "$arg_name" "$arg"
                    fi

                    butl.set_var "__barg_arg_${arg_name}_filled" 1
                    next_arg_index=$((next_arg_index + 1))
                else
                    if butl.is_declared "$arg_name"; then
                        local current_values=()
                        if butl.is_array "$arg_name"; then
                            butl.copy_array "$arg_name" current_values
                        fi

                        current_values+=("$arg")
                        butl.copy_array current_values "$arg_name"
                    fi

                    local filled_var="__barg_arg_${arg_name}_filled"
                    local filled=${!filled_var:-0}
                    filled=$((filled + 1))
                    butl.set_var "$filled_var" "$filled"

                    if ((filled >= ${#arg_values[@]})); then
                        next_arg_index=$((next_arg_index + 1))
                    fi
                fi

                processed_arg=1
            fi
        fi

        if ((processed_arg)); then
            continue
        fi

        if [[ "${__barg_catchall_arg:-}" ]]; then
            local var_arg_allow_dash="__barg_arg_${__barg_catchall_arg}_allow_dash"
            local arg_allow_dash=${!var_arg_allow_dash}

            if [[ "$arg" == -?* ]]; then
                if ((process_args_only || arg_allow_dash)); then
                    catchall_array+=("$arg")
                    continue
                fi
            else
                catchall_array+=("$arg")
                continue
            fi
        fi

        butl.log_error "Unknown argument: ${BUTL_ANSI_UNDERLINE}${arg}${BUTL_ANSI_RESET_UNDERLINE}."
        failed=1
    done

    if ! ((${__barg_disable_help:-0})) && ((${barg_help:-0})); then
        if ((failed)); then
            # Leave an empty line after the error messages
            echo
        fi

        barg.print_usage
        barg.reset
        if butl.is_declared should_exit; then
            butl.set_var should_exit 1
            if ((failed)); then
                if butl.is_declared should_exit_err; then
                    butl.set_var should_exit_err 1
                fi
                return 1
            else
                return 0
            fi
        elif ((failed)); then
            exit 1
        else
            exit 0
        fi
    fi

    # Set the catchall flag if any
    if [[ "${__barg_catchall_arg:-}" ]]; then
        butl.copy_array "catchall_array" "$__barg_catchall_arg"
    fi

    __barg_postprocess_options
    __barg_postprocess_flags
    __barg_postprocess_args

    if ((${#catchall_array[@]} == 0)) && [[ "${__barg_catchall_arg:-}" ]]; then
        local var_catchall_required="__barg_arg_${__barg_catchall_arg}_required"
        local catchall_required=${!var_catchall_required}

        if ((catchall_required)); then
            butl.log_error "Argument ${BUTL_ANSI_UNDERLINE}$arg${BUTL_ANSI_RESET_UNDERLINE} is required."
            failed=1
        fi
    fi

    if ((failed)) || __barg_has_subcommands 1; then
        if ((failed)); then
            # Leave an empty line after the error messages
            echo
        fi

        barg.print_usage
        barg.reset
        if butl.is_declared should_exit; then
            butl.set_var should_exit 1
            if butl.is_declared should_exit_err; then
                butl.set_var should_exit_err 1
            fi
            return 1
        else
            exit 1
        fi
    fi

    barg.reset
}

__barg_parse_option() {
    processed_arg=1
    if ! butl.is_declared "$option"; then
        return
    fi

    local option_values=()
    butl.copy_array "__barg_option_${option}_values" option_values

    local value_count=${#option_values[@]}
    if ((value_count > $#)); then
        : "Option ${BUTL_ANSI_UNDERLINE}${option_arg}${BUTL_ANSI_RESET_UNDERLINE}"
        butl.log_error "$_ requires ${BUTL_ANSI_UNDERLINE}${value_count}${BUTL_ANSI_RESET_UNDERLINE} values."
        failed=1
        return
    fi

    local var_option_multi="__barg_option_${option}_multi"
    local option_multi="${!var_option_multi}"

    if ((option_multi)); then
        local values=()
        butl.copy_array "$option" "values"
        values+=("${@:1:$value_count}")
        butl.set_array "$option" "${values[@]}"
    else
        if ((value_count > 1)); then
            butl.set_array "$option" "${@:1:$value_count}"
        else
            butl.set_var "$option" "$1"
        fi
    fi

    # set implied flags to 1
    local option_implies=()
    butl.copy_array "__barg_option_${option}_implies" "option_implies"
    for implied_flag in "${option_implies[@]-}"; do
        if [[ ! "$implied_flag" ]]; then
            continue
        fi

        if [[ " ${__barg_flags[*]} " != *" $implied_flag "* ]]; then
            : "Option ${BUTL_ANSI_UNDERLINE}${option_arg}${BUTL_ANSI_RESET_UNDERLINE}"
            : "$_ implies ${BUTL_ANSI_UNDERLINE}${implied_flag}${BUTL_ANSI_RESET_UNDERLINE},"
            : "$_ but ${BUTL_ANSI_UNDERLINE}${implied_flag}${BUTL_ANSI_RESET_UNDERLINE}"
            butl.log_error "$_ is not a flag."
            failed=1
            return
        fi

        butl.set_var "$implied_flag" 1
    done

    shift_count=$value_count

    # mark the option as set
    butl.set_var "__barg_option_${option}_set" 1
}

__barg_parse_flag() {
    processed_arg=1
    if ! butl.is_declared "$flag"; then
        return
    fi

    butl.set_var "$flag" 1

    # set implied flags to 1
    local flag_implies=()
    butl.copy_array "__barg_flag_${flag}_implies" "flag_implies"
    for implied_flag in "${flag_implies[@]-}"; do
        if [[ ! "$implied_flag" ]]; then
            continue
        fi

        if [[ " ${__barg_flags[*]} " != *" $implied_flag "* ]]; then
            butl.log_error "Flag $flag_arg implies '$implied_flag', but $implied_flag is not a flag."
            failed=1
            return
        fi

        butl.set_var "$implied_flag" 1
    done
}

__barg_postprocess_options() {
    # Fill from env or set default values for unset options
    for option in "${__barg_options[@]-}"; do
        if [[ ! "$option" ]]; then
            continue
        fi

        # Make sure required options are set
        local var_option_required="__barg_option_${option}_required"
        local option_required=${!var_option_required}

        local var_option_set="__barg_option_${option}_set"
        local option_set=${!var_option_set}

        local var_option_env="__barg_option_${option}_env"
        local option_env=${!var_option_env-}

        local option_defaults=()
        butl.copy_array "__barg_option_${option}_defaults" option_defaults

        # Skip if variable is not declared, or if an array; not empty.
        if ! butl.is_declared "$option"; then
            continue
        fi

        if ((option_set)); then
            continue
        fi

        local option_is_updated=

        # Set default value from enviornment
        if [[ "$option_env" && "${!option_env+x}" ]]; then
            # shellcheck disable=SC2059
            butl.set_var "$option" "${!option_env}"

            option_is_updated=1
        elif ((${#option_defaults[@]})); then
            if butl.is_array "$option"; then
                butl.copy_array "$option" option_defaults
                option_is_updated=1
            else
                # shellcheck disable=SC2059
                butl.set_var "$option" "${option_defaults[0]}"

                option_is_updated=1
            fi
        fi

        if ((option_required)) && ! ((option_set || option_is_updated)) \
            && ! { [[ "$option_env" && "${!option_env+x}" ]] || ((${#option_defaults[@]})); }; then
            local var_option_long="__barg_option_${option}_long"
            local option_param=${!var_option_long}
            if [[ ! "$option_param" ]]; then # long form is not set, fall back to short form
                local var_option_short="__barg_option_${option}_short"
                local option_param=${var_option_short}
            fi

            butl.log_error "Option ${BUTL_ANSI_UNDERLINE}$option_param${BUTL_ANSI_RESET_UNDERLINE} is required."
            failed=1
            continue
        fi

        # Update implied flags
        if ((option_is_updated)); then
            # mark the option as set
            butl.set_var "$var_option_set" 1

            local option_implies=()
            butl.copy_array "__barg_option_${option}_implies" "option_implies"
            for implied_flag in "${option_implies[@]-}"; do
                if [[ ! "$implied_flag" ]]; then
                    continue
                fi

                if [[ " ${__barg_flags[*]} " != *" $implied_flag "* ]]; then
                    butl.log_error "Option $option implies '$implied_flag', but $implied_flag is not a flag."
                    failed=1
                    return
                fi

                butl.set_var "$implied_flag" 1
            done
        fi
    done
}

__barg_postprocess_flags() {
    # Fill from env or set default values for unset flags
    for flag in "${__barg_flags[@]-}"; do
        if [[ ! "$flag" ]]; then
            continue
        fi

        # Skip if variable is not declared or not empty
        if ! butl.is_declared "$flag" || [[ "${!flag:-}" ]]; then
            continue
        fi

        # Set default value from environment
        local var_flag_env="__barg_flag_${flag}_env"
        local flag_env=${!var_flag_env-}
        if [[ ! "$flag_env" ]] || ! ((${!flag_env:-})); then
            butl.set_var "$flag" ''
            continue
        fi

        butl.set_var "$flag" 1

        # Update implied flags
        local flag_implies=()
        butl.copy_array "__barg_flag_${flag}_implies" "flag_implies"
        for implied_flag in "${flag_implies[@]-}"; do
            if [[ ! "$implied_flag" ]]; then
                continue
            fi

            if [[ " ${__barg_flags[*]} " != *" $implied_flag "* ]]; then
                : "Flag ${BUTL_ANSI_UNDERLINE}${flag}${BUTL_ANSI_RESET_UNDERLINE}"
                : "$_ implies ${BUTL_ANSI_UNDERLINE}${implied_flag}${BUTL_ANSI_RESET_UNDERLINE},"
                : "$_ but ${BUTL_ANSI_UNDERLINE}${implied_flag}${BUTL_ANSI_RESET_UNDERLINE}"
                butl.log_error "$_ is not a flag."
                failed=1
                continue
            fi

            butl.set_var "$implied_flag" 1
        done
    done
}

__barg_postprocess_args() {
    # Check the values of normal arguments
    for arg in "${__barg_args[@]-}"; do
        if [[ ! "$arg" ]] || [[ "$arg" == "${__barg_catchall_arg:-}" ]]; then
            continue
        fi

        local var_arg_filled="__barg_arg_${arg}_filled"
        local arg_filled=${!var_arg_filled:-}

        local arg_defaults=()
        butl.copy_array "__barg_arg_${arg}_defaults" arg_defaults

        # Make sure required args are set
        local var_arg_required="__barg_arg_${arg}_required"
        local arg_required=${!var_arg_required}
        if ((arg_required)) && ! ((arg_filled)) && ! ((${#arg_defaults[@]})); then
            butl.log_error "Argument ${BUTL_ANSI_UNDERLINE}$arg${BUTL_ANSI_RESET_UNDERLINE} is required."
            failed=1
            continue
        fi

        if ! butl.is_declared "$arg"; then
            continue
        fi

        local arg_values=()
        butl.copy_array "__barg_arg_${arg}_values" arg_values

        if ((arg_filled == ${#arg_values[@]})); then
            continue
        fi

        if ((arg_filled)); then
            : "Argument ${BUTL_ANSI_UNDERLINE}$arg${BUTL_ANSI_RESET_UNDERLINE}"
            butl.log_error "$_ requires ${#arg_values[@]} values, but only ${arg_filled} were given."
            failed=1
            continue
        fi

        # Set defaults
        if butl.is_array "$arg"; then
            butl.copy_array arg_defaults "$arg"
            butl.set_var "$var_arg_filled" "${#arg_defaults[@]}"
            arg_filled=${#arg_defaults[@]}
        elif ((${#arg_defaults[@]} > 0)); then
            butl.set_var "$arg" "${arg_defaults[0]}"
            butl.set_var "$var_arg_filled" 1
            arg_filled=1
        fi
    done
}
# BGEN__END /home/sdrm/projects/barg/lib/barg/_parse.sh
# BGEN__BEGIN /home/sdrm/projects/barg/lib/barg/_usage.sh
# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/columns.sh
# BGEN__SHEBANG_REMOVED

# Formats tab separated stdin entries as columns
# @param out_separator:  String to separate the output with (default: '  ')
# @param in_separator:  Single character to separate the input with (defualt '<tab>')
butl.columns() {
    local out_separator=${1:-"  "}
    local in_separator=${2:-$'\t'}

    if column -o "$out_separator" -s "$in_separator" -t -L 2>/dev/null; then
        return
    fi

    # parse manually
    local column_widths=()
    local lines=()
    local cell

    # for each column find the longest cell
    while IFS= read -r line; do
        if [[ "$line" ]]; then
            local i=0
            while IFS= read -r cell; do
                local cell_width
                cell_width="${#cell}"
                if ((cell_width > column_widths[i])); then
                    column_widths[$i]="$cell_width"
                fi
                i=$((i + 1))
            done <<<"${line//$in_separator/$'\n'}"
        fi

        lines+=("$line")
    done

    # generate a printf string such as it can print each cells at a given width
    local printf_query
    printf_query=$(printf -- "%%-%ss$out_separator" "${column_widths[@]::$((${#column_widths[@]} - 1))}")
    printf_query+="%s"

    for line in "${lines[@]-}"; do
        local cells=()

        if [[ ! "$line" ]]; then
            # Replicating column behaviour
            for cell in "${column_widths[@]}"; do
                cells+=("")
            done
        else
            while IFS= read -r cell; do
                cells+=("$cell")
            done <<<"${line//$in_separator/$'\n'}"
        fi

        # shellcheck disable=SC2059
        printf "$printf_query\n" "${cells[@]}"
    done
}
# BGEN__END /home/sdrm/projects/butl/lib/butl/columns.sh
# BGEN__BEGIN /home/sdrm/projects/butl/lib/butl/strip_ansi.sh
# BGEN__SHEBANG_REMOVED

# Strips style ansi escape codes from string
# @param input?:  Text to strip. If not set, reads from stdin
butl.strip_ansi_style() {
    local keep_extglob=0
    if shopt -qp extglob; then
        keep_extglob=1
    fi

    if (($#)); then
        local input=$1
    else
        local input
        read -d "" -r input || true
    fi

    shopt -s extglob
    echo "${input//\\@(e|x1[bB])\[[0-9]?([0-9])*([;:]?([0-9]?([0-9])))[m]/}"

    if ! ((keep_extglob)); then
        shopt -u extglob
    fi
}

# Strips all ansi escape codes from string
# @param input?:  Text to strip. If not set, reads from stdin
butl.strip_ansi() {
    local keep_extglob=0
    if shopt -qp extglob; then
        keep_extglob=1
    fi

    if (($#)); then
        local input=$1
    else
        local input
        read -d "" -r input || true
    fi

    shopt -s extglob
    echo "${input//\\@(e|x1[bB])\[[0-9]?([0-9])*([;:]?([0-9]?([0-9])))[ABCDEFGHJKSTfmin]/}"

    if ! ((keep_extglob)); then
        shopt -u extglob
    fi
}
# BGEN__END /home/sdrm/projects/butl/lib/butl/strip_ansi.sh

# Prints help/usage text base on the declared commands, arguments and options
# shellcheck disable=SC2120
barg.print_usage() {
    local subcommand_name=${1:-}
    if [[ "$subcommand_name" ]]; then
        barg.print_subcommand_usage "$subcommand_name"
        return
    fi

    # check whether script is source or directly executed
    local process process_dir process_file process_base
    if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
        process="$__BGEN_PIPE_SOURCE__"
    elif [[ "${BASH_SOURCE+x}" ]]; then
        process="${BASH_SOURCE[0]}"
    else
        process="$0"
    fi

    # Set magic variables for current file, directory, os, etc.
    process_dir="$(cd "$(dirname "${process}")" && pwd)"
    process_file="${process_dir}/$(basename "${process}")"
    # shellcheck disable=SC2034,SC2015
    process_base="$(basename "${process_file}" .sh)"

    local process_base=${process_base:-$0}
    local arg_list=()
    local section_break=

    # shellcheck disable=SC2154
    if ((${#__barg_subcommands[@]})); then
        arg_list+=("SUBCOMMAND")
    fi

    # shellcheck disable=SC2154
    if ((${#__barg_flags[@]})); then
        arg_list+=("[FLAGS...]")
    fi

    # shellcheck disable=SC2154
    if ((${#__barg_options[@]})); then
        arg_list+=("[OPTIONS...]")
    fi

    # shellcheck disable=SC2154
    local arg_count=${#__barg_args[@]}
    if ((arg_count)); then
        for arg in "${__barg_args[@]}"; do
            # shellcheck disable=SC2154
            if [[ "$arg" == "${__barg_catchall_arg:-}" ]]; then
                continue
            fi

            local var_arg_values="__barg_arg_${arg}_values"
            local arg_values=()
            butl.copy_array "$var_arg_values" "arg_values"

            local value="${arg_values[0]:-ARGS}"
            arg_list+=("${value}")
        done

        # add the catch all at the end
        if [[ "${__barg_catchall_arg:-}" ]]; then
            local var_arg_values="__barg_arg_${__barg_catchall_arg}_values"
            local arg_values=()
            butl.copy_array "$var_arg_values" "arg_values"

            local value="${arg_values[0]:-ARGS}"
            arg_list+=("[${value}...]")
        fi
    fi

    # Print usage
    # shellcheck disable=SC2154
    printf '%bUSAGE:%b\n' "$__barg_style_title" "$__barg_style_reset"
    printf '    %s%s\n' "$process_base" "$(printf ' %s' "${arg_list[@]-}")"
    section_break=1

    # shellcheck disable=SC2154
    local flag_desc_cr_threshold=$__barg_usage_flag_desc_length_threshold
    # shellcheck disable=SC2154
    local option_desc_cr_threshold=$__barg_usage_option_desc_length_threshold
    # shellcheck disable=SC2154
    local arg_desc_cr_threschold=$__barg_usage_arg_desc_length_threshold

    __barg_print_usage_section "SUBCOMMANDS" "$(__barg_print_subcommands)"
    __barg_print_usage_section "FLAGS" "$(__barg_print_flags)"
    __barg_print_usage_section "OPTIONS" "$(__barg_print_options)"
    __barg_print_usage_section "ARGUMENTS" "$(__barg_print_args)"
}

# Print usage text for a given subcommand
barg.print_subcommand_usage() {
    local subcommand="$1"

    if butl.is_array __barg_subcommands && [[ " ${__barg_subcommands[*]-} " == *" $subcommand "* ]]; then
        command_func_var="__barg_subcommand_${subcommand//-/_}_func"
        command_func="${!command_func_var}"
        barg.reset
        "$command_func" --help
        return
    fi

    local msg="There's no help subject on: ${BUTL_ANSI_UNDERLINE}${subcommand}${BUTL_ANSI_RESET_UNDERLINE}\n"
    butl.log_error "$msg"
    barg.print_usage
    return 1
}

__barg_is_lastline_too_long() {
    local size_threshold=$1
    if ((size_threshold == 0)); then
        return 1
    fi

    : "${2##*$'\n'}"
    : "$(butl.strip_ansi_style "$_")"
    ((${#_} > size_threshold))
}

__barg_print_usage_section() {
    local title=$1
    local text=$2

    if [[ "$text" ]]; then
        if ((section_break)); then
            echo
        fi

        printf '%b%s:%b\n' "$__barg_style_title" "$title" "$__barg_style_reset"
        butl.columns ' ' <<<"$text"

        section_break=1
    fi
}

__barg_print_subcommands() {
    for subcommand in "${__barg_subcommands[@]-}"; do
        [[ "$subcommand" ]] || continue
        local subcommand_desc_var="__barg_subcommand_${subcommand//-/_}_desc"
        local subcommand_desc="${!subcommand_desc_var:-}"
        # shellcheck disable=SC2154
        printf '    %b%s%b\t %s\n' "$__barg_style_arg" "$subcommand" \
            "$__barg_style_reset" "$subcommand_desc"
    done
}

__barg_print_flags() {
    for flag in "${__barg_flags[@]-}"; do
        if [[ ! "$flag" ]]; then
            continue
        fi

        local flag_desc_var="__barg_flag_${flag}_desc"
        local flag_desc="${!flag_desc_var:-}"

        local flag_short_var="__barg_flag_${flag}_short"
        local flag_short="${!flag_short_var:-}"

        local flag_long_var="__barg_flag_${flag}_long"
        local flag_long="${!flag_long_var:-}"

        local flag_env_var="__barg_flag_${flag}_env"
        local flag_env="${!flag_env_var:-}"

        if [[ ! "${flag_short:-}${flag_long:-}" ]]; then
            continue
        fi

        if [[ "${flag_short:-}" ]]; then
            printf '    %b-%s%b' "$__barg_style_arg" "$flag_short" "$__barg_style_reset"
        else
            printf '    %b  %b' "$__barg_style_arg" "$__barg_style_reset"
        fi

        if [[ "${flag_short:-}" && "${flag_long:-}" ]]; then
            printf ',\t'
        else
            printf '\t'
        fi

        if [[ "${flag_long:-}" ]]; then
            printf '%b--%s%b' "$__barg_style_arg" "$flag_long" "$__barg_style_reset"
        else
            printf '%b%b' "$__barg_style_arg" "$__barg_style_reset"
        fi

        local desc=" $flag_desc"

        if [[ "${flag_env}" ]]; then
            if __barg_is_lastline_too_long "$flag_desc_cr_threshold" "$desc"; then
                desc+=$'\n'
            fi

            # shellcheck disable=SC2154
            desc+=$(printf ' %b[env: %b%s%b=%b%s%b]%b' "$__barg_style_info" \
                "$__barg_style_info_var" "$flag_env" "$__barg_style_info_equals" \
                "$__barg_style_info_value" "${!flag_env:-}" \
                "$__barg_style_info" "$__barg_style_reset")
        fi

        : "${desc//$'\n'/$'\n\t\t '}"
        printf '\t %s\n' "$_"
    done
}

__barg_print_options() {
    for option in "${__barg_options[@]-}"; do
        if [[ ! "$option" ]]; then
            continue
        fi

        local option_desc_var="__barg_option_${option}_desc"
        local option_desc=${!option_desc_var:-}

        local option_short_var="__barg_option_${option}_short"
        local option_short=${!option_short_var:-}

        local option_long_var="__barg_option_${option}_long"
        local option_long=${!option_long_var:-}

        local option_env_var="__barg_option_${option}_env"
        local option_env=${!option_env_var:-}

        local option_values
        butl.copy_array "__barg_option_${option}_values" option_values

        local option_defaults
        butl.copy_array "__barg_option_${option}_defaults" option_defaults

        if [[ ! "${option_short:-}${option_long:-}" ]]; then
            continue
        fi

        printf '    '

        if [[ "${__barg_options_have_short:-}" ]]; then
            if [[ "${option_short:-}" ]]; then
                printf '%b-%s%b' "$__barg_style_arg" "$option_short" "$__barg_style_reset"
            else
                printf '%b  %b' "$__barg_style_arg" "$__barg_style_reset"
            fi

            if [[ "${option_short:-}" && "${option_long:-}" ]]; then
                printf ',\t'
            else
                printf '\t'
            fi
        fi

        if [[ "${__barg_options_have_long:-}" ]]; then
            if [[ "${option_long:-}" ]]; then
                printf '%b--%s%b' "$__barg_style_arg" "$option_long" "$__barg_style_reset"
            else
                printf '%b%b' "$__barg_style_arg" "$__barg_style_reset"
            fi
        fi

        if [[ "${option_values[0]-}" ]]; then
            local values_str
            values_str=$(printf ' <%s>' "${option_values[@]}")
            if [[ ! "${option_long:-}" ]]; then
                values_str=${values_str:1}
            fi
            printf '%b%s%b' "$__barg_style_arg" "$values_str" "$__barg_style_reset"
        fi

        local desc="$option_desc"

        if [[ "${option_defaults[0]-}" ]]; then
            if __barg_is_lastline_too_long "$option_desc_cr_threshold" "$desc"; then
                desc+=$'\n'
            fi

            local join_separator="$__barg_style_reset, $__barg_style_info_value"
            desc+=$(printf ' %b[default: %b%b%b]%b' "$__barg_style_info" "$__barg_style_info_value" \
                "$(butl.join_by "$join_separator" "${option_defaults[@]}")" \
                "$__barg_style_info" "$__barg_style_reset")
        fi

        if [[ "${option_env}" ]]; then
            if __barg_is_lastline_too_long "$option_desc_cr_threshold" "$desc"; then
                desc+=$'\n'
            fi

            desc+=$(printf ' %b[env: %b%s%b=%b%s%b]%b' "$__barg_style_info" \
                "$__barg_style_info_var" "$option_env" "$__barg_style_info_equals" \
                "$__barg_style_info_value" "${!option_env:-}" \
                "$__barg_style_info" "$__barg_style_reset")
        fi

        : "${desc//$'\n'/$'\n\t\t'}"
        printf '\t %s\n' "$_"
    done
}

__barg_print_args() {
    for arg in "${__barg_args[@]-}"; do
        if [[ ! "$arg" ]]; then
            continue
        fi

        local arg_desc_var="__barg_arg_${arg}_desc"
        local arg_desc=${!arg_desc_var:-}

        local arg_env_var="__barg_arg_${arg}_env"
        local arg_env=${!arg_env_var:-}

        local arg_values
        butl.copy_array "__barg_arg_${arg}_values" arg_values

        local arg_defaults
        butl.copy_array "__barg_arg_${arg}_defaults" arg_defaults

        if [[ "${arg_values[0]-}" ]]; then
            printf '   %b%s%b' "$__barg_style_arg" \
                "$(printf ' <%s>' "${arg_values[@]}")" "$__barg_style_reset"
        fi

        local desc=" $arg_desc"

        if [[ "${arg_defaults[0]-}" ]]; then
            if __barg_is_lastline_too_long "$arg_desc_cr_threschold" "$desc"; then
                desc+=$'\n'
            fi

            local join_separator="$__barg_style_reset, $__barg_style_info_value"
            desc+=$(printf ' %b[default: %b%b%b]%b' \
                "$__barg_style_info" "$__barg_style_info_value" \
                "$(butl.join_by "$join_separator" "${arg_defaults[@]}")" \
                "$__barg_style_info" "$__barg_style_reset")
        fi

        if [[ "${arg_env}" ]]; then
            if __barg_is_lastline_too_long "$arg_desc_cr_threschold" "$desc"; then
                desc+=$'\n'
            fi

            desc+=$(printf ' %b[env: %b%s%b=%b%s%b]%b' \
                "$__barg_style_info" "$__barg_style_info_var" \
                "$arg_env" "$__barg_style_info_equals" "$__barg_style_info_value" \
                "${!arg_env:-}" "$__barg_style_info" "$__barg_style_reset")
        fi

        : "${desc//$'\n'/$'\n\t'}"
        printf '\t %s\n' "$_"
    done
}
# BGEN__END /home/sdrm/projects/barg/lib/barg/_usage.sh

# shellcheck disable=SC2034
: "${__barg_style_title:="${BUTL_ANSI_RESET}${BUTL_ANSI_YELLOW}"}"
# shellcheck disable=SC2034
: "${__barg_style_arg:="${BUTL_ANSI_RESET}${BUTL_ANSI_GREEN}"}"
# shellcheck disable=SC2034
: "${__barg_style_info:="${BUTL_ANSI_RESET}${BUTL_ANSI_DIM}"}"
# shellcheck disable=SC2034
: "${__barg_style_info_var:="${__barg_style_info}${BUTL_ANSI_UNDERLINE}"}"
# shellcheck disable=SC2034
: "${__barg_style_info_equals:="${__barg_style_info}"}"
# shellcheck disable=SC2034
: "${__barg_style_info_value:="${BUTL_ANSI_RESET}${BUTL_ANSI_CYAN}"}"
# shellcheck disable=SC2034
: "${__barg_style_reset:="${BUTL_ANSI_RESET}"}"

# shellcheck disable=SC2034
: "${__barg_usage_arg_desc_length_threshold:=0}"
# shellcheck disable=SC2034
: "${__barg_usage_flag_desc_length_threshold:=0}"
# shellcheck disable=SC2034
: "${__barg_usage_option_desc_length_threshold:=0}"

# Declare a subcommand
# @param subcommand         name of the subcommand
# @param subcommand_func    command to call for this subcommand
# shellcheck disable=2059
barg.subcommand() {
    local subcommand=$1
    local subcommand_func=$2
    local subcommand_desc=$3

    if ! butl.is_array __barg_subcommands; then
        __barg_subcommands=()
    fi

    __barg_subcommands+=("$subcommand")

    printf -v "__barg_subcommand_${subcommand//-/_}_func" "$subcommand_func"
    printf -v "__barg_subcommand_${subcommand//-/_}_desc" "$subcommand_desc"
}

# When called, barg doesn't append its help command/flag
barg.disable_help() {
    # shellcheck disable=SC2034
    __barg_disable_help=1
}

# Declare an argument
# shellcheck disable=2059
barg.arg() {
    local second_pass_args=()
    local arg_values=()
    local arg_defaults=()
    local arg_implies=()
    local arg_multi=

    local arg=
    local arg_desc=
    local arg_short=
    local arg_long=
    local arg_env=
    local arg_hidden=
    local arg_allow_dash=
    local arg_required=

    while (($#)); do
        case "$1" in
        --value)
            arg_values+=("$2")
            shift 2
            ;;
        --value=*)
            arg_values+=("${1#--value=}")
            shift
            ;;
        *)
            second_pass_args+=("$1")
            shift
            ;;
        esac
    done
    if ((${#second_pass_args[@]})); then
        set -- "${second_pass_args[@]}"
    fi

    while (($#)); do
        case "$1" in
        --short)
            arg_short=$2
            shift 2
            ;;
        --short=*)
            arg_short=${1#--short=}
            shift
            ;;
        --long)
            arg_long=$2
            shift 2
            ;;
        --long=*)
            arg_long=${1#--long=}
            shift
            ;;
        --desc)
            arg_desc=$2
            shift 2
            ;;
        --desc=*)
            arg_desc=${1#--desc=}
            shift
            ;;
        --env)
            arg_env=$2
            shift 2
            ;;
        --env=*)
            arg_env=${1#--env=}
            shift
            ;;
        --default)
            arg_defaults+=("$2")
            shift 2
            ;;
        --default=*)
            arg_defaults+=("${1#--default=}")
            shift
            ;;
        --defaults)
            local value_count=${#arg_values[@]}
            arg_defaults=("${@:1:$value_count}")
            shift "$value_count"
            ;;
        --multi)
            arg_multi=1
            shift
            ;;
        --implies)
            arg_implies+=("$2")
            shift 2
            ;;
        --implies=*)
            arg_implies+=("${1#--implies=}")
            shift
            ;;
        --hidden)
            arg_hidden=1
            shift
            ;;
        --allow-dash)
            local arg_allow_dash=1
            shift
            ;;
        --required)
            local arg_required=1
            shift
            ;;
        *)
            if [[ "$arg" ]]; then
                butl.fail "barg.arg: expected 1 argument ($arg), but another one was given: $1"
                return
            fi

            local arg="$1"
            shift
            ;;
        esac
    done

    if ((${#arg_values[@]})) && [[ "$arg_short" || "$arg_long" ]]; then
        # handle options
        butl.is_array __barg_options || __barg_options=()

        butl.set_var "__barg_option_${arg}_desc" "${arg_desc:-}"
        butl.set_var "__barg_option_${arg}_short" "${arg_short:-}"
        butl.set_var "__barg_option_${arg}_long" "${arg_long:-}"
        butl.set_var "__barg_option_${arg}_env" "${arg_env:-}"
        butl.set_var "__barg_option_${arg}_multi" "${arg_multi:-}"
        butl.set_var "__barg_option_${arg}_hidden" "${arg_hidden:-}"
        butl.set_var "__barg_option_${arg}_required" "${arg_required:-}"
        butl.copy_array arg_values "__barg_option_${arg}_values"
        butl.copy_array arg_defaults "__barg_option_${arg}_defaults"
        butl.copy_array arg_implies "__barg_option_${arg}_implies"

        if [[ "${arg_short:-}" ]]; then
            butl.set_var "__barg_options_have_short" 1
        fi

        if [[ "${arg_long:-}" ]]; then
            butl.set_var "__barg_options_have_long" 1
        fi

        __barg_options+=("$arg")
    elif [[ "$arg_short" || "$arg_long" ]]; then
        # handle flags
        butl.is_array __barg_flags || __barg_flags=()

        butl.set_var "__barg_flag_${arg}_desc" "${arg_desc:-}"
        butl.set_var "__barg_flag_${arg}_short" "${arg_short:-}"
        butl.set_var "__barg_flag_${arg}_long" "${arg_long:-}"
        butl.set_var "__barg_flag_${arg}_env" "${arg_env:-}"
        butl.set_var "__barg_flag_${arg}_hidden" "${arg_hidden:-}"
        butl.copy_array arg_implies "__barg_flag_${arg}_implies"

        if [[ "${arg_short:-}" ]]; then
            butl.set_var "__barg_flags_have_short" 1
        fi

        if [[ "${arg_long:-}" ]]; then
            butl.set_var "__barg_flags_have_long" 1
        fi

        __barg_flags+=("$arg")
    elif ((${#arg_values[@]})); then
        if ((arg_multi)); then
            if [[ "${__barg_catchall_arg:-}" ]]; then
                butl.fail "cannot define more than one catchall argument"
                return
            fi

            __barg_catchall_arg=$arg
        fi

        # handle arguments
        butl.is_array __barg_args || __barg_args=()

        butl.set_var "__barg_arg_${arg}_desc" "${arg_desc:-}"
        butl.set_var "__barg_arg_${arg}_env" "${arg_env:-}"
        butl.set_var "__barg_arg_${arg}_hidden" "${arg_hidden:-}"
        butl.set_var "__barg_arg_${arg}_allow_dash" "${arg_allow_dash:-}"
        butl.set_var "__barg_arg_${arg}_required" "${arg_required:-}"
        butl.copy_array arg_values "__barg_arg_${arg}_values"
        butl.copy_array arg_defaults "__barg_arg_${arg}_defaults"

        __barg_args+=("$arg")
    else
        butl.fail "Argument should either have a --long/-short form, a value name, or both."
    fi
}

# Resets internal variables to their clean state
# shellcheck disable=SC2154
barg.reset() {
    unset __barg_disable_help

    unset __barg_subcommands
    unset "${!__barg_subcommand_@}"

    unset __barg_flags
    unset "${!__barg_flag_@}"
    unset "${!__barg_flags_@}"

    unset __barg_options
    unset "${!__barg_option_@}"
    unset "${!__barg_options_@}"

    unset __barg_args
    unset "${!__barg_arg_@}"
    unset "${!__barg_args_@}"

    unset __barg_catchall_arg
}

# Checks if there are any subcommands
__barg_has_subcommands() {
    if ! butl.is_array __barg_subcommands || ((${#__barg_subcommands[@]} == 0)); then
        return 1
    fi

    local count_hidden=${1:-0}
    if ((count_hidden)); then
        return 0
    fi

    local count=0
    for subcommand in "${__barg_subcommands[@]}"; do
        local var_subcommand_hidden="__barg_subcommand_${subcommand}_hidden"
        local subcommand_hidden=${!var_subcommand_hidden:-}

        if ! ((subcommand_hidden)); then
            count=$((count += 1))
        fi
    done

    ((count > 0))
}

# Checks if there are any options
__barg_has_options() {
    if ! butl.is_array __barg_options || ((${#__barg_options[@]} == 0)); then
        return 1
    fi

    local count_hidden=${1:-0}
    if ((count_hidden)); then
        return 0
    fi

    local count=0
    for option in "${__barg_options[@]}"; do
        local var_option_hidden="__barg_option_${option}_hidden"
        local option_hidden=${!var_option_hidden:-}

        if ! ((option_hidden)); then
            count=$((count += 1))
        fi
    done

    ((count > 0))
}

# Checks if there are any flags
__barg_has_flags() {
    if ! butl.is_array __barg_flags || ((${#__barg_flags[@]} == 0)); then
        return 1
    fi

    local count_hidden=${1:-0}
    if ((count_hidden)); then
        return 0
    fi

    local count=0
    for flag in "${__barg_flags[@]}"; do
        local var_flag_hidden="__barg_flag_${flag}_hidden"
        local flag_hidden=${!var_flag_hidden:-}

        if ! ((flag_hidden)); then
            count=$((count += 1))
        fi
    done

    ((count > 0))
}

# Checks if there are any args
__barg_has_args() {
    if ! butl.is_array __barg_args || ((${#__barg_args[@]} == 0)); then
        return 1
    fi

    local count_hidden=${1:-0}
    if ((count_hidden)); then
        return 0
    fi

    local count=0
    for arg in "${__barg_args[@]}"; do
        local var_arg_hidden="__barg_arg_${arg}_hidden"
        local arg_hidden=${!var_arg_hidden:-}

        if ! ((arg_hidden)); then
            count=$((count += 1))
        fi
    done

    ((count > 0))
}
# BGEN__END /home/sdrm/projects/barg/lib/barg.sh

# BGEN__BEGIN /home/sdrm/projects/bgen/src/build.sh
# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/bgen/src/utils.sh
# BGEN__SHEBANG_REMOVED

bail() {
    local err_message="$1"
    local err_code="${2:-1}"

    echo "$err_message" >&2
    exit "$err_code"
}

trim_str() {
    : "${1#${1%%[![:space:]]*}}"
    echo "${_%${_##*[![:space:]]}}"
}
# BGEN__END /home/sdrm/projects/bgen/src/utils.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/lib/meta.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/butl/lib/butl/vars.sh

# shellcheck disable=SC2034
read_project_meta() {
    butl.is_declared import_paths || local import_paths

    # make sure some vars are local if not declared on a parent scope
    butl.is_declared project_root || local project_root=
    butl.is_declared project_name || local project_name=
    butl.is_declared header_file || local header_file=
    butl.is_declared entrypoint_file || local entrypoint_file=
    butl.is_declared entrypoint_func || local entrypoint_func=
    butl.is_declared source_dir || local source_dir=
    butl.is_declared shebang_string || local shebang_string=
    butl.is_declared tests_dir || local tests_dir=
    butl.is_declared output_file || local output_file=
    butl.is_declared output_dir || local output_dir=
    butl.is_declared is_library || local is_library=

    # set some defaults
    shebang_string="#!/usr/bin/env bash"
    tests_dir="tests"
    output_dir="dist"

    local import_paths_extra=()
    import_paths=()
    import_paths=("deps/*/lib")

    # source config file
    project_root="$PWD"
    while true; do
        # shellcheck disable=SC1091
        if [[ -f ".bgenrc" ]]; then
            project_root="$PWD"
            source ".bgenrc"
            break
        elif [[ -f "bgenrc.sh" ]]; then
            project_root="$PWD"
            source "bgenrc.sh"
            break
        fi

        if [[ "$PWD" == "/" ]]; then
            cd "$project_root" || return
            break
        fi

        cd ..
    done

    # If there's a lib/ directory, but no src/ directory, assume it's a library
    if [[ ! "$is_library" && -d "lib" && ! -d "src" ]]; then
        is_library=1
    fi

    # source directory is lib for libraries and src for single script files
    if [[ ! "$source_dir" ]]; then
        if ((is_library)); then
            source_dir="lib"
        else
            source_dir="src"
        fi
    fi

    # set the default entrypoint file
    if [[ ! "$entrypoint_file" ]]; then
        if ((is_library)); then
            entrypoint_file=""
        else
            entrypoint_file="${source_dir%/}/main.sh"
        fi
    fi

    # set default project name
    if [[ ! "${project_name:-}" ]]; then
        # ${file##*/} keeps only what's after the last slash (aka the basename)
        project_name="${PWD##*/}"
    fi

    # set default output file
    if [[ ! "${output_file:-}" ]]; then
        if ((is_library)); then
            output_file=""
        else
            output_file="${output_dir%/}/${project_name#/}"
        fi
    fi

    # set default entrypoint function
    if [[ ! "${entrypoint_func:-}" ]]; then
        if ((is_library)); then
            entrypoint_func=""
        else
            entrypoint_func="$project_name"
        fi
    fi

    # add the extra import paths
    if ((${#import_paths_extra[@]})); then
        import_paths=("${import_paths_extra[@]}" "${import_paths[@]}")
    fi

    # add env paths, give them more priority
    if [[ "${BGEN_IMPORT_PATHS:-}" ]]; then
        local env_paths=()
        while read -rd ':' path; do
            env_paths+=("$path")
        done <<<"${BGEN_IMPORT_PATHS}:"
        import_paths=("${env_paths[@]}" "${import_paths[@]}")
    fi
}
# BGEN__END /home/sdrm/projects/bgen/src/lib/meta.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/lib/build.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/butl/lib/butl/vars.sh
# BGEN__ALREADY_IMPORTED /home/sdrm/projects/butl/lib/butl/arrays.sh

echo_shebang() {
    if [[ "${shebang_string:-}" ]]; then
        printf '%s\n\n' "$shebang_string"
    fi
}

echo_header() {
    local header_file=${header_file:-}
    if [[ -f "$header_file" ]]; then
        process_file "$header_file"
    else
        local default_header
# BGEN__INCLUDE_STR_BEGIN
        read -rd '' default_header <<-"BGEN_EOF_17772_26794" || :
			#!/usr/bin/env bash
			
			set -o errexit -o errtrace -o pipefail -o nounset
			
			LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
			NO_COLOR="${NO_COLOR:-}"
			BGEN_EOF_17772_26794
# BGEN__INCLUDE_STR_END
        process_input <<<"$default_header"
    fi

    # Add some spacing
    printf '\n\n'
}

process_file() {
    local file
    file=$(find_file "$1")

    # get directory name
    : "${file%/*}"
    local src_dir=${_:-/}

    pushd "$src_dir" >/dev/null || return
    process_input <"$file"
    popd >/dev/null || return
}

process_input() {
    local found_first_line=
    while IFS= read -r line; do
        local err=0

        # Process source directives that point ot static files
        process_directive "$line" || err=$?
        if ((err == 200)); then
            continue
        elif ((err)); then
            return $err
        fi

        # Remove first shebang in the file
        if ! [[ "$found_first_line" ]]; then
            process_shebang "$line" || err=$?
            if ((err == 200)); then
                continue
            elif ((err)); then
                return $err
            fi
        fi

        if [[ ! "$found_first_line" ]]; then
            if ! echo "$line" | grep -E "^[[:space:]]*$" >/dev/null; then
                found_first_line=1
            fi
        fi

        # Otherwise echo the line as is
        echo "$line"
    done
}

echo_entrypoint_call() {
    local entrypoint_func=${entrypoint_func:-}

    if [[ "$entrypoint_func" ]]; then
        # shellcheck disable=SC2016
        printf '\n[[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]] || %s "$@"\n' "$entrypoint_func"
    fi
}

process_shebang() {
    local line
    line=$(trim_str "$1")

    if [[ "$line" =~ ^\#\! ]]; then
        found_first_line=1
        echo "# BGEN__SHEBANG_REMOVED"
        return 200
    fi
}

process_directive() {
    local line=$1
    if ! [[ "$line" =~ ^[[:space:]]*bgen\: ]]; then
        return 0
    fi

    : "${line%%[![:space:]]*}"
    local indent_size=${#_}

    # escape `` and $()
    : "${line//\`/\\\`}"
    : "${_//\$/\\\$}"
    : "${_//\(/\\\(}"
    : "${_//\)/\\/)}"
    declare -a "args=( $_ )"

    # parse arguments
    if (("${#args[@]}" == 0)); then
        return 0
    fi

    local directive=${args[0]}
    args=("${args[@]:1}")

    case "$directive" in
    "bgen:import") bgen_import "${args[@]}" ;;
    "bgen:include") bgen_include "${args[@]}" ;;
    "bgen:include_str") bgen_include_str "${args[@]}" ;;
    "bgen:"*) butl.fail "unknown bgen directive: $directive" ;;
    *) ;;
    esac
}

find_file() {
    local file=$1

    # check if the file exists
    if [[ -r "$file" && -f "$file" ]]; then
        realpath "$file"
        return
    fi

    # check in import directories
    # shellcheck disable=SC2154
    for unexpanded_dir in "${import_paths[@]}"; do
        for dir in $unexpanded_dir; do
            # make sure external files are always imported relative to project dir
            if [[ "$dir" != /* ]]; then
                dir="${project_root:-$PWD}/$dir"
            fi

            if [[ -r "$dir/$file" && -f "$dir/$file" ]]; then
                realpath "$dir/$file"
                return
            fi
        done
    done

    # nothing found :(
    echo "file does not exist or is not readable: $file" >&2
    return 1
}

find_source_file() {
    local file=$1

    find_file "${file}.sh" 2>/dev/null || find_file "$file"
}

bgen_import() {
    local file
    file=$(find_source_file "$1")

    # Don't re-import file if it was already imported
    if butl.index_of "$file" "${imported_files[@]-}"; then
        echo "# BGEN__ALREADY_IMPORTED $file"
    else
        # Mark file as imported
        imported_files+=("$file")

        # Add a comment indicating where the processing starts
        echo "# BGEN__BEGIN $file"

        # Do normal file processing
        process_file "$file"

        # Add a comment indicating where the processing starts
        echo "# BGEN__END $file"
    fi

    # Return 200 to tell check() that we've processed something
    return 200
}

bgen_include() {
    local file
    file=$(find_source_file "$1")

    # Add a comment indicating where the processing starts
    echo "# BGEN__BEGIN $file"

    # Do normal file processing
    process_file "$file"

    # Add a comment indicating where the processing starts
    echo "# BGEN__END $file"

    return 200
}

bgen_include_str() {
    local variable=$1
    local file
    file=$(find_file "$2")

    local TAB_SIZE=4
    local indent_size=${indent_size:-0}
    local tabs=$((indent_size / TAB_SIZE))
    local indent
    indent=$(printf "%${indent_size}s")
    indent_plus=$(printf '\t%.0s' $(seq $((tabs + 1))))

    local heredoc_id="${RANDOM}_${RANDOM}"
    echo "# BGEN__INCLUDE_STR_BEGIN"
    echo "${indent}read -rd '' ${variable} <<-\"BGEN_EOF_${heredoc_id}\" || :"
    while IFS= read -r line; do
        echo "$indent_plus$line"
    done <"$file"
    echo "${indent_plus}BGEN_EOF_${heredoc_id}"
    echo "# BGEN__INCLUDE_STR_END"

    # Return 200 to tell check() that we've processed something
    return 200
}
# BGEN__END /home/sdrm/projects/bgen/src/lib/build.sh

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/barg/lib/barg.sh
# BGEN__ALREADY_IMPORTED /home/sdrm/projects/butl/lib/butl/log.sh

command_build() {
    barg.arg print_source \
        --short=p \
        --long=print-source \
        --desc "Print test script's source code instead of executing it."
    barg.arg minify \
        --short=m \
        --long=minify \
        --desc "Minify using shfmt if available."

    local print_source=
    local minify=0

    local should_exit=
    local should_exit_err=0
    barg.parse "$@"
    if ((should_exit)); then
        return "$should_exit_err"
    fi

    if ((minify)) && ! command -v shfmt >/dev/null 2>/dev/null; then
        butl.log_warning "shfmt command not found, minifying will be disabled"

        minify=0
    fi

    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    # shellcheck disable=2034
    local imported_files=()

    # shellcheck disable=2034
    local header_file=
    # shellcheck disable=2034
    local entrypoint_func=
    # shellcheck disable=2034
    local shebang_string=
    # shellcheck disable=2034
    local import_paths=
    local entrypoint_file=
    local is_library=
    local source_dir=
    local output_dir=
    read_project_meta

    if ((is_library)); then
        if ((print_source)); then
            build_library_file "$file"
        else
            build_library
        fi
    else
        if ((print_source)); then
            build_file "$entrypoint_file"
        else
            build_project
        fi
    fi
}

build_library_file() {
    local file="$1"

    # set a constant seed to have consistent builds
    RANDOM=42

    echo_shebang
    if ((${minify:-})); then
        process_file "$file" | shfmt -mn
    else
        process_file "$file"
    fi
}

build_library() {
    if shopt -qs globstar; then
        local keep_globstar=1
    fi

    shopt -s globstar
    for file in "${source_dir%/}"/**/*.sh; do
        # If we have the same path as the query, then we got no file
        if [[ "$file" == "${source_dir%/}/**/*.sh" ]]; then
            echo "broke free" >&2
            break
        fi

        # ignore files that start with an underscore
        if [[ "${file##*/}" == _* ]]; then
            continue
        fi

        local output_file="${output_dir%/}/${file##$source_dir\/}"
        mkdir -p "${output_file%/*}"

        build_library_file "$file" >"$output_file"
        butl.log_info "Built: $output_file"
    done

    if ! ((keep_globstar)); then
        shopt -u globstar
    fi

    butl.log_notice "Done"
}

build_project() {
    # save it in a temp file first
    local tmp_file
    tmp_file=$(mktemp /tmp/bgen.XXXXXXXXXX)
    # shellcheck disable=SC2064
    trap "rm '$tmp_file' >/dev/null || true" exit

    # build the project
    build_file "$entrypoint_file" >"$tmp_file"

    # shellcheck disable=SC1007
    local output_file=""
    read_project_meta

    # get output_file's directory
    : "${output_file%/*}"
    local output_dir="${_:-/}"

    # make sure the output's directory exists
    if [[ "$output_dir" && "$output_dir" != "." ]]; then
        mkdir -p "$output_dir"
    fi

    # copy it to the real output dir and make it executable
    cp "$tmp_file" "$output_file"
    chmod +x "$output_file"
    butl.log_info "Built: $output_file"

    butl.log_notice "Done"
}

build_file() {
    local entrypoint=$1

    echo_shebang

    local output
    output=$(
        # set a constant seed to have consistent builds
        RANDOM=42

        echo_header
        process_file "$entrypoint"
        echo_entrypoint_call
    )

    if ((${minify:-})); then
        echo "$output" | shfmt -mn
    else
        echo "$output"
    fi
}
# BGEN__END /home/sdrm/projects/bgen/src/build.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/run.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/bgen/src/build.sh

command_run() {
    barg.arg debug \
        --short=d \
        --long=debug \
        --desc "Run the project in debug mode."
    barg.arg args \
        --multi \
        --value=ARGUMENT \
        --desc="Arguments to pass to the project."

    local debug=
    local args=()

    local should_exit=
    local should_exit_err=0
    barg.parse "$@"
    if ((should_exit)); then
        return "$should_exit_err"
    fi

    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    # shellcheck disable=2034
    local imported_files=()

    # shellcheck disable=2034
    local header_file=
    # shellcheck disable=2034
    local entrypoint_func=
    # shellcheck disable=2034
    local shebang_string=
    # shellcheck disable=2034
    local import_paths=
    # shellcheck disable=2034
    local entrypoint_file=
    local is_library=
    read_project_meta

    if ((is_library)); then
        butl.die "You cannot run library projects."
    elif ((debug)); then
        debug_project "${args[@]}"
    else
        run_project "${args[@]}"
    fi
}

run_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} run"
    bash -c "$(build_file "$entrypoint_file")" "${__base__:-$0} run" "$@"
}

debug_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} debug"
    bash -x -c "$(build_file "$entrypoint_file")" "${__base__:-$0} run" "$@"
}
# BGEN__END /home/sdrm/projects/bgen/src/run.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/tests.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/bgen/src/lib/meta.sh
# BGEN__ALREADY_IMPORTED /home/sdrm/projects/bgen/src/lib/build.sh

command_test() {
    barg.arg targets \
        --multi \
        --value=FILE \
        --desc="Test script files or directories to run."
    barg.arg test_funcs \
        --multi \
        --short=k \
        --value FUNC \
        --desc "Names of test functions to run."
    barg.arg no_capture \
        --short=O \
        --long=no-capture \
        --env=BGEN_NO_CAPTURE \
        --desc "Also show the output of succeeding tests."
    barg.arg coverage \
        --short=c \
        --long=coverage \
        --env=BGEN_COVERAGE \
        --desc "Make a code coverage report."
    barg.arg coverage_experimental \
        --implies=coverage \
        --short=C \
        --long=coverage-experimental \
        --env=BGEN_COVERAGE_EXPERIMENTAL \
        --desc "Enable experimental code coverage features."
    barg.arg coverage_debug \
        --implies=no_capture \
        --implies=coverage \
        --short=D \
        --long=coverage-debug \
        --env=BGEN_COVERAGE_DEBUG \
        --desc "Print lines as they're executed to stderr."
    barg.arg coverage_file \
        --short=H \
        --long=html-report \
        --value=FILE \
        --default=coverage.html \
        --env=BGEN_HTML_REPORT_FILE \
        --desc "Name of the coverage html report."
    barg.arg print_source \
        --short=p \
        --long=print-source \
        --desc "Print test script's source code instead of executing it."

    local targets=()
    local test_funcs=()
    local no_capture=
    local coverage=
    local coverage_experimental=
    local coverage_debug=
    local coverage_file=
    local print_source=

    local should_exit=
    local should_exit_err=0
    barg.parse "$@"
    if ((should_exit)); then
        return "$should_exit_err"
    fi

    # shellcheck disable=2034
    local project_root=
    # shellcheck disable=2034
    local header_file=
    # shellcheck disable=2034
    local shebang_string=
    # shellcheck disable=2034
    local import_paths=
    local tests_dir=
    local entrypoint_file=
    local entrypoint_func=
    local source_dir=
    local is_library=
    read_project_meta

    # check whether bgen is sourced or directly executed
    local process process_dir process_file process_base
    if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
        process="$__BGEN_PIPE_SOURCE__"
    elif [[ "${BASH_SOURCE+x}" ]]; then
        process="${BASH_SOURCE[0]}"
    else
        process="$0"
    fi

    # Set magic variables for current file, directory, os, etc.
    process_dir="$(cd "$(dirname "${process}")" && pwd)"
    process_file="${process_dir}/$(basename "${process}")"
    # shellcheck disable=SC2034,SC2015
    process_base="$(basename "${process_file}" .sh)"

    local process_base=${process_base:-$0}
    export __BGEN_PIPE_SOURCE__="$process_base test"

    local script_file
    script_file=$(mktemp)
    # shellcheck disable=SC2064
    trap "rm -rf '$script_file'" EXIT

    build_tests_to_stdout >"$script_file"

    if ((print_source)); then
        cat "$script_file"
    else
        bash "$script_file"
    fi
}

build_tests_to_stdout() {
    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    # shellcheck disable=2034
    local imported_files=()

    local test_files=()
    if ! ((${#targets[@]})); then
        # make sure tests directory exists
        if ! [[ -d "$tests_dir" ]]; then
            butl.fail "tests directory '$tests_dir' does not exist"
            return
        fi

        collect_testfiles_in_dir "$tests_dir"
    else
        for target in "${targets[@]}"; do
            if [[ -d "$target" ]]; then
                collect_testfiles_in_dir "$target"
            else
                test_files+=("$target")
            fi
        done
    fi

    # build the tests file
    echo_shebang
    echo_header

    # pre-including the project for tests to have better coverage reports
    if ((is_library)); then
        if shopt -qs globstar; then
            local keep_globstar=1
        fi

        shopt -s globstar
        for file in "${source_dir%/}"/**/*.sh; do
            # If we have the same path as the query, then we got no file
            if [[ "$file" == "${source_dir%/}/**/*.sh" ]]; then
                break
            fi

            # ignore files that start with an underscore
            if [[ "${file##*/}" == _* ]]; then
                continue
            fi

            local err=0
            bgen_import "$file" || err=$?
            if ((err != 200)); then
                if ! ((keep_globstar)); then
                    shopt -u globstar
                fi

                return $err
            fi
        done

        if ! ((keep_globstar)); then
            shopt -u globstar
        fi
    elif [[ "$entrypoint_func" && -s "$entrypoint_file" ]]; then
        # if there's no entrypoint function, we assume the entrypoint file
        # runs actual code and that can cause problems during tests
        local err=0
        bgen_import "$entrypoint_file" || err=$?
        if ((err != 200)); then
            return $err
        fi
    fi

    for test_file in "${test_files[@]}"; do
        [[ -f "$test_file" ]] || continue

        local err=0
        bgen_import "$test_file" || err=$?
        if ((err != 200)); then
            return $err
        fi
    done

    if ((${#test_funcs[@]})); then
        echo "__BGEN_TEST_FUNCS__=("
        printf '    %q\n' "${test_funcs[@]}"
        echo ")"
    fi

    echo "BGEN_NO_CAPTURE=$no_capture"
    echo "BGEN_COVERAGE=$coverage"
    echo "BGEN_COVERAGE_EXPERIMENTAL=$coverage_experimental"
    echo "BGEN_COVERAGE_DEBUG=$coverage_debug"
    printf "BGEN_HTML_REPORT_FILE=%q\n\n" "$coverage_file"

    local assertlib
# BGEN__INCLUDE_STR_BEGIN
    read -rd '' assertlib <<-"BGEN_EOF_1435_24388" || :
		#!/usr/bin/env bash
		# shellcheck disable=SC2034
		
		assert_eq() {
		    local left="$1"
		    local right="$2"
		
		    if [[ "$left" == "$right" ]]; then
		        return 0
		    fi
		
		    printf 'assert_eq sides do not match\nleft:\n%s\n\nright:\n%s\n' "$left" "$right" >&2
		
		    # save line at which this happened, used later for reporting
		    __bgen_assert_line="${BASH_LINENO[0]-}"
		
		    return 1
		}
		export -f assert_eq
		
		assert_exits_with() {
		    local args=()
		
		    unset __bgen_assert_code
		    unset __bgen_assert_stdout
		    unset __bgen_assert_stderr
		
		    while (($#)); do
		        case "$1" in
		        --code)
		            local __bgen_assert_code=$2
		            shift 2
		            ;;
		        --code=*)
		            local __bgen_assert_code=${1#--code=}
		            shift
		            ;;
		        --stdout)
		            local __bgen_assert_stdout=$2
		            shift 2
		            ;;
		        --stdout=*)
		            local __bgen_assert_stdout=${1#--stdout=}
		            shift
		            ;;
		        --stderr)
		            local __bgen_assert_stderr=$2
		            shift 2
		            ;;
		        --stderr=*)
		            local __bgen_assert_stderr=${1#--stderr=}
		            shift
		            ;;
		        --)
		            shift
		            args+=("$@")
		            shift $#
		            ;;
		        *)
		            args+=("$1")
		            shift
		            ;;
		        esac
		    done
		
		    local err=0
		
		    local stderr_file
		    stderr_file=$(mktemp)
		
		    if ((BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 2 && BASH_VERSINFO[1] <= 3)); then
		        local stdout_file
		        stdout_file=$(mktemp)
		
		        # Working around bash 4.2 and 4.3 not returning the correct exit code of subprocesses
		        err=$(
		            trap '__bgen_test_debug_handler "$?" "$LINENO" "$BASH_COMMAND" "$_"' DEBUG
		            trap 'trap - DEBUG; __bgen_test_error_handler "$LINENO"' ERR
		            trap 'trap - DEBUG; __bgen_test_exit_handler "$LINENO"' EXIT
		
		            "${args[@]}" 1>"$stdout_file" 2>"$stderr_file" || echo $?
		        ) || err=$?
		
		        if [[ ! "$err" ]]; then
		            err=0
		        fi
		
		        local stdout
		        stdout=$(<"$stdout_file")
		        rm "$stdout_file"
		    else
		        local stdout
		        stdout=$("${args[@]}" 2>"$stderr_file") || err=$?
		    fi
		
		    local stderr
		    stderr=$(<"$stderr_file")
		    rm "$stderr_file"
		
		    local report=()
		
		    if [[ "${__bgen_assert_code+x}" ]] && ((__bgen_assert_code != err)); then
		        report+=("$(printf "expected exit code: %s\nreturned exit code: %s\n" "$__bgen_assert_code" "$err")")
		    fi
		
		    if [[ "${__bgen_assert_stdout+x}" ]] && [[ "$__bgen_assert_stdout" != "$stdout" ]]; then
		        report+=("$(
		            printf "expected stdout: %s\nreturned stdout: %s\n" \
		                "$(cat -vte <<<"$__bgen_assert_stdout")" \
		                "$(cat -vte <<<"$stdout")"
		        )")
		    fi
		
		    if [[ "${__bgen_assert_stderr+x}" ]] && [[ "$__bgen_assert_stderr" != "$stderr" ]]; then
		        report+=("$(
		            printf "expected stderr: %s\nreturned stderr: %s\n" \
		                "$(cat -vte <<<"$__bgen_assert_stderr")" \
		                "$(cat -vte <<<"$stderr")"
		        )")
		    fi
		
		    if ((${#report[@]})); then
		        printf 'assert_exits_with failed on %s:\n' "${args[*]}" >&2
		        printf '%s\n' "${report[@]}" >&2
		
		        # save line at which this happened, used later for reporting
		        __bgen_assert_line="${BASH_LINENO[0]-}"
		
		        return 1
		    fi
		
		    return 0
		}
		export -f assert_exits_with
		BGEN_EOF_1435_24388
# BGEN__INCLUDE_STR_END
    process_input <<<"$assertlib"

    local bootstrap
# BGEN__INCLUDE_STR_BEGIN
    read -rd '' bootstrap <<-"BGEN_EOF_11074_32198" || :
		#!/usr/bin/env bash
		
		__bgen_test_entrypoint() {
		    local failed_tests_funcs=()
		    local test_reports=()
		
		    local coverage_map=()
		    local trails_map=()
		
		    if [[ "${BASH_EXECUTION_STRING:-}" ]]; then
		        __BGEN_TEST_SOURCE=$BASH_EXECUTION_STRING
		    elif [[ -f "${BASH_SOURCE[0]-}" ]]; then
		        __BGEN_TEST_SOURCE=$(<"${BASH_SOURCE[0]}")
		    else
		        echo "Cannot file source code" >&2
		        exit 1
		    fi
		
		    # linemap shows at what lines each file starts and ends
		    if [[ ! "${__BGEN_TEST_LINEMAP:-}" ]]; then
		        local linemap=()
		        local line_nr=0
		        while IFS= read -r line; do
		            line_nr=$((line_nr + 1))
		
		            local line="${line#${line%%[![:space:]]*}}" # strip leading whitepsace if any
		            if [[ "$line" =~ ^\#[[:space:]]BGEN__ ]]; then
		                linemap+=("$line_nr ${line:2}")
		            fi
		        done <<<"$__BGEN_TEST_SOURCE"
		
		        local linemap_str
		        linemap_str="$(__bgen_test_join_by $'\n' "${linemap[@]}")"
		        export __BGEN_TEST_LINEMAP="$linemap_str"
		    fi
		
		    # loop over test functions
		    printf "%bRunning tests...%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		    local passed_test_count=0
		    local total_test_count=0
		    if declare -p __BGEN_TEST_FUNCS__ >/dev/null 2>&1; then
		        # bgen test created a variable with specific tests to run
		        for test_func in "${__BGEN_TEST_FUNCS__[@]}"; do
		            __bgen_test_run_single "$test_func"
		            total_test_count=$((total_test_count + 1))
		        done
		    else
		        # no specific tests to run, find and run all tests that start with test_xxxx
		        while IFS= read -r line; do
		            if [[ "$line" == "declare -f test_"[[:alnum:]]* ]]; then
		                local test_func="${line#${line%%test_*}}"
		                __bgen_test_run_single "$test_func"
		                total_test_count=$((total_test_count + 1))
		            fi
		        done < <(declare -F)
		    fi
		
		    if ((total_test_count == 0)); then
		        echo "    No tests to run :("
		    else
		        # return to line after the dots
		        echo
		    fi
		
		    if (("${#test_reports[@]}")); then
		        for test_report in "${test_reports[@]}"; do
		            echo "$test_report"
		        done
		        printf '\n%b-----%b' "$__BGEN_TEST_COL_FILENAME" "$__BGEN_TEST_COL_RESET"
		    fi
		
		    if (("${#failed_tests_funcs[@]}")); then
		        printf "\n%bFailed tests:%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		        for test_func in "${failed_tests_funcs[@]}"; do
		            echo "    $test_func"
		        done
		    fi
		
		    # report on coverage if requested
		    : "${BGEN_COVERAGE:=0}"
		    : "${BGEN_HTML_REPORT_FILE:=}"
		    : "${BGEN_COVERAGE_M_THRESHOLD:=60}"
		    : "${BGEN_COVERAGE_H_THRESHOLD:=85}"
		    if ((BGEN_COVERAGE)); then
		        printf "\n%bCoverage:%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		        __bgen_test_make_coverage_report
		    fi
		
		    if ((total_test_count > 0)); then
		        local n_tests
		        if ((total_test_count == 1)); then
		            n_tests="1 test"
		        else
		            n_tests=$(printf '%s tests' "$total_test_count")
		        fi
		
		        # exit with error if any test failed
		        if ((${#failed_tests_funcs[@]})); then
		            printf '\n%b%s/%s passed failed%b\n' \
		                "$__BGEN_TEST_COL_DANGER" $((total_test_count - passed_test_count)) "$n_tests" "$__BGEN_TEST_COL_RESET"
		            exit 1
		        else
		            printf '\n%s\n%b%s passed successfully%b\n' \
		                "☆*･゜ﾟ･*(^O^)/*･゜ﾟ･*☆" "$__BGEN_TEST_COL_SUCCESS" "$n_tests" "$__BGEN_TEST_COL_RESET"
		        fi
		    fi
		}
		
		# requires 2 variables: source_file and source_line_nr to be declared
		__bgen_test_get_source_line() {
		    local bgen_line=$1
		
		    # stacks to keep track of...
		    local files_stack=("UNKNOWN_FILE") # which file we're currently processing
		    local line_nrs_stack=(0)           # the start line number of the file
		    local offsets_stack=(0)            # how much lines should we offset from this file's linecount
		
		    while IFS= read -r line; do
		        # parse the line number
		        local line=${line#${line%%[![:space:]]*}} # strip leading whitespace if any
		        local line_nr=${line%%[[:space:]]*}       # strip everything from the first space
		
		        if ((line_nr > bgen_line)); then
		            break
		        fi
		
		        # bash 3.2 seems to complain when i use case .. in .. esac here
		        if [[ "$line" =~ ^[[:digit:]]+[[:space:]]+BGEN__BEGIN[[:space:]]+ ]]; then
		            : "${line#*BGEN__BEGIN[[:space:]]}"
		            local file=${_#${_%%[![:space:]]*}}
		
		            # add values related to this file to the new stack
		            files_stack=("$file" "${files_stack[@]}")
		            line_nrs_stack=("$line_nr" "${line_nrs_stack[@]}")
		            offsets_stack=(0 "${offsets_stack[@]}")
		        elif [[ "$line" =~ ^[[:digit:]]+[[:space:]]+BGEN__END[^[:alnum:]]+ ]]; then
		            local file_start_line_nr=${line_nrs_stack[0]}
		            local file_lines=$((line_nr - file_start_line_nr))
		
		            # pop the first item from the stack
		            files_stack=("${files_stack[@]:1}")
		            line_nrs_stack=("${line_nrs_stack[@]:1}")
		            offsets_stack=("${offsets_stack[@]:1}")
		
		            # offset the previous item's lines with the linecount of this file
		            offsets_stack[0]=$((offsets_stack[0] + file_lines))
		        fi
		    done <<<"$__BGEN_TEST_LINEMAP"
		
		    if declare -p source_file 1>/dev/null 2>&1; then
		        source_file="${files_stack[0]/$PWD\//}"
		    fi
		
		    if declare -p source_line_nr 1>/dev/null 2>&1; then
		        source_line_nr=$((bgen_line - line_nrs_stack[0] - offsets_stack[0]))
		    fi
		}
		export -f __bgen_test_get_source_line
		
		# called when a test's subprocess exits with a non-zero return code
		__bgen_test_error_handler() {
		    local rc=$__bgen_test_current_rc
		
		    # get error line number
		    if [[ "${__bgen_assert_line:-}" ]]; then
		        # bash versions <=4.3 only call the handler AFTER the returning function was left
		        # the workaround here is to have assert functions to keep track of the line they left at instead
		        local line_nr=$__bgen_assert_line
		
		        # once again seems bash versions <=5.0 totally ignore the shebang's line
		        if ((BASH_VERSINFO[0] < 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] < 1))); then
		            line_nr=$((line_nr + 1))
		        fi
		    elif [[ "$__bgen_test_current_cmd" == "$__bgen_test_prev_cmd" ]]; then
		        # if we have two successive return commands, use the previous one's line
		        # workaround for when bash reports the return AFTER the returning to the parent function
		        local line_nr=$__bgen_test_prev_line_nr
		    else
		        local line_nr=$__bgen_test_current_line_nr
		
		        # bash 3.2 strangely uses the previous line for errors
		        if ((BASH_VERSINFO[0] < 4)); then
		            line_nr=$((line_nr + 1))
		        fi
		    fi
		
		    # prevent the exit_handler from outputting anything since it's also executed
		    __bgen_test_error_handled=1
		
		    if [[ "$__bgen_test_main_subshell" == "$BASH_SUBSHELL" ]]; then
		        # print the original source file and line number for easy debugging
		        local source_file=
		        local source_line_nr=
		        __bgen_test_get_source_line "$line_nr"
		        printf '%b%s:%s (status: %s)%b\n' \
		            "$__BGEN_TEST_COL_DANGER" "$source_file" "$source_line_nr" "$rc" "$__BGEN_TEST_COL_RESET" >&2
		    fi
		
		    # exit with the same return code we came with
		    exit "$rc"
		}
		export -f __bgen_test_error_handler
		
		# called when a test's subprocess exits
		__bgen_test_exit_handler() {
		    local rc=$__bgen_test_current_rc
		    local subshell_mode=${2:-}
		
		    # save coverage lines into a file, only way to communicate them to the parent process
		    local env_file="$__bgen_env_dir/${BASH_SUBSHELL}_${RANDOM}_${RANDOM}.env"
		    declare -p __bgen_test_covered_lines >>"$env_file"
		
		    if [[ "${__bgen_test_subshell_line_count+x}" ]]; then
		        local __bgen_test_subshell_trails=()
		        __bgen_test_subshell_trails[$__bgen_test_subshell_line_end]=$((__bgen_test_subshell_line_count))
		        declare -p __bgen_test_subshell_trails >>"$env_file"
		    fi
		
		    # if the error handler was already triggered, don't do anything else here
		    if ((${__bgen_test_error_handled:-})) || ((subshell_mode)); then
		        exit "$rc"
		    fi
		
		    # more reliable than LINENO
		    local line_nr=$__bgen_test_prev_line_nr
		
		    # get exit line number
		    if ((rc == 0)); then
		        # workaround for bash <4.0 returning 0 on nounset errors
		        [[ "${__func_finished_successfully:-}" ]] && exit 0
		
		        # this is the same code bash returns on version 4+ in these cases
		        rc=127
		
		        if [[ "${__bgen_test_prev_line_nr:-}" ]]; then
		            line_nr=$((__bgen_test_prev_line_nr))
		        fi
		    elif [[ "${__bgen_test_prev_line_nr:-}" ]]; then
		        line_nr=$__bgen_test_prev_line_nr
		    fi
		
		    # print the original source and line number for easy debugging
		    local source_file=
		    local source_line_nr=
		    __bgen_test_get_source_line "$line_nr"
		    printf '%b%s:%s (status: %s)%b\n' \
		        "$__BGEN_TEST_COL_DANGER" "$source_file" "$source_line_nr" "$rc" "$__BGEN_TEST_COL_RESET" >&2
		
		    # exit with the same return code we came with
		    exit "$rc"
		}
		export -f __bgen_test_exit_handler
		
		# called before each line, use to keep track of what lines
		# were executed, and which are the last 2 commands and their rc and line numbers
		# used for error reporting and code coverage
		__bgen_test_debug_handler() {
		    local rc=$1
		    local line_nr=$2
		    local cmd=$3
		    local old_=$4
		
		    if [[ ! "${__bgen_previous_rc+x}" ]]; then
		        export __bgen_previous_rc=0
		        export __bgen_test_prev_cmd=
		        export __bgen_test_prev_line_nr=1
		    else
		        export __bgen_previous_rc=$__bgen_test_current_rc
		        if ((__bgen_previous_rc == 0)); then
		            export __bgen_test_prev_cmd=$__bgen_test_current_cmd
		            export __bgen_test_prev_line_nr=$__bgen_test_current_line_nr
		        fi
		    fi
		
		    if [[ "${__bgen_test_main_subshell:-}" != "$BASH_SUBSHELL" ]]; then
		        trap 'trap - DEBUG; __bgen_test_exit_handler "$LINENO" 1' EXIT
		
		        # special case for multiline output subshells "$(\n ... )"
		        if [[ "$__bgen_test_prev_cmd" == *$'\n'* ]]; then
		            # calculate number of lines by removing all \n chars
		            # and getting character difference from the original string
		            : "${__bgen_test_prev_cmd//$'\n'/}"
		            __bgen_test_subshell_line_count=$((${#__bgen_test_prev_cmd} - ${#_} + 1))
		
		            __bgen_test_subshell_line_start=$((__bgen_test_prev_line_nr - __bgen_test_subshell_line_count + 1))
		            __bgen_test_subshell_line_end=$((__bgen_test_prev_line_nr))
		        fi
		    fi
		
		    export __bgen_test_current_rc=$rc
		    export __bgen_test_current_cmd=$cmd
		
		    if [[ "${__bgen_test_subshell_line_start+x}" ]] && ((\
		    __bgen_test_subshell_line_start <= line_nr && line_nr >= __bgen_test_subshell_line_end)); then
		        line_nr=$((line_nr - __bgen_test_subshell_line_count + 1))
		        __bgen_test_covered_lines[$line_nr]=2 # run this in the second pass
		    else
		        line_nr="$line_nr"
		        __bgen_test_covered_lines[$line_nr]=1
		    fi
		    export __bgen_test_current_line_nr=$line_nr
		
		    if ((${BGEN_COVERAGE_DEBUG:-})); then
		        local source_line_nr=
		        local source_file=
		        __bgen_test_get_source_line "$line_nr"
		        printf -- '%s %s %-4s %-4s %s %s\n' "$rc" "$BASH_SUBSHELL" \
		            "$source_line_nr" "$line_nr" \
		            "${__bgen_test_covered_lines[$line_nr]}" "$cmd" >&2
		    fi
		
		    # restore the original value of $_
		    : "$old_"
		}
		export -f __bgen_test_debug_handler
		
		# joins lines with a delimited
		__bgen_test_join_by() {
		    if (($# <= 1)); then
		        return 0
		    fi
		
		    local delimiter=$1
		    local first=$2
		    shift 2
		
		    printf '%s' "$first" "${@/#/$delimiter}"
		}
		
		# Returns true if a line is covered according to the coverage map
		__bgen_is_line_covered() {
		    local line_nr=$1
		    local line=$2
		
		    # check for nocov comments
		    if ((in_nocov)); then
		        if [[ "$line" =~ \#[[:space:]][[:space:]]*nocov[[:space:]]end($|[[:space:]]) ]]; then
		            in_nocov=
		        fi
		
		        return 0
		    elif [[ "$line" =~ \#[[:space:]][[:space:]]*nocov($|[[:space:]]) ]]; then
		        if [[ "$line" =~ \#[[:space:]][[:space:]]*nocov[[:space:]]begin($|[[:space:]]) ]]; then
		            in_nocov=1
		        fi
		
		        return 0
		    fi
		
		    if [[ "$line" =~ ([^\\]|^)\\$ ]]; then
		        # lines ends with backslash
		        pending_lines=$((pending_lines + 1))
		        skip_line=1
		
		        if ((coverage_map[line_nr])); then
		            # It is also covered, so we mark the next line as covered instead
		            coverage_map[$((line_nr + 1))]=${coverage_map[line_nr]}
		        fi
		
		        return 1
		    fi
		
		    if ((coverage_map[line_nr])); then
		        # line is in the coverage map
		        return 0
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*$ ]]; then
		        # line is empty space
		        # covered only if the previous line also covered
		        ((${is_prev_line_covered-}))
		        return
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*else[[:space:]]*$ ]]; then
		        # line is an else statement
		        pending_lines=$((pending_lines + 1))
		        skip_line=1
		        return 1
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*\# ]]; then
		        # line is a comment
		        # covered only if the previous line also covered
		        pending_lines=$((pending_lines + 1))
		        skip_line=1
		        return 1
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*(\(|\{|\)|\}|do|done|then|fi)[[:space:]]*$ ]]; then
		        # line is a single curly brace or parenthesis
		        # covered only if the previous line also covered
		        ((${is_prev_line_covered-}))
		        return
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*done[[:space:]]*\< ]]; then
		        # line is done statement followed by a redirection
		        ((${is_prev_line_covered-}))
		        return
		    fi
		
		    # otherwise, line is not covered
		    return 1
		}
		
		# Returns the index of the first item among the rest of the items
		# returns -1 if the item is not found
		__bgen_test_find_index_of() {
		    local target=$1
		    shift
		
		    local i=0
		    while (($#)); do
		        if [[ "$1" == "$target" ]]; then
		            index=$i
		            return 0
		        fi
		
		        i=$((i + 1))
		        shift
		    done
		
		    index=-1
		    return 1
		}
		
		# prints coverage report for a given file
		__bgen_test_add_file_report() {
		    local filename=$1
		    local covered_hunks=$2
		    local covered_lines_count=$3
		    local total_lines_count=$4
		
		    local index
		    if __bgen_test_find_index_of "$filename" "${cov_files[@]-}"; then
		        : "${cov_hunks[$index]}"
		        local -a "exhunks=(${_//,/ })"
		
		        for hunk in ${covered_hunks//,/ }; do
		            local newhunks=()
		            local covered_lines_count=0
		
		            if [[ "$hunk" == *-* ]]; then
		                local start=${hunk%-*}
		                local end=${hunk#*-}
		            else
		                local start=$hunk
		                local end=$hunk
		            fi
		
		            local placed=0
		            local i=0
		            while ((i < ${#exhunks[@]})); do
		                local ihunk=${exhunks[$i]}
		
		                if [[ "$ihunk" == *-* ]]; then
		                    local istart=${ihunk%-*}
		                    local iend=${ihunk#*-}
		                else
		                    local istart=$ihunk
		                    local iend=$ihunk
		                fi
		
		                if ((placed == 0 && end + 1 < istart)); then
		                    if ((start == end)); then
		                        newhunks+=("$start")
		                        covered_lines_count=$((covered_lines_count + 1))
		                    else
		                        newhunks+=("$start-$end")
		                        covered_lines_count=$((covered_lines_count - start + end + 1))
		                    fi
		
		                    local j=$i
		                    while ((j < ${#exhunks[@]})); do
		                        local jhunk=${exhunks[$j]}
		
		                        if [[ "$jhunk" == *-* ]]; then
		                            local jstart=${jhunk%-*}
		                            local jend=${jhunk#*-}
		                            covered_lines_count=$((covered_lines_count - jstart + jend + 1))
		                        else
		                            covered_lines_count=$((covered_lines_count + 1))
		                        fi
		
		                        j=$((j + 1))
		                    done
		                    newhunks+=("${exhunks[@]:$i}")
		
		                    placed=1
		                    break
		                fi
		
		                if ((start >= istart && end <= iend)); then
		                    start=$istart
		                    end=$iend
		                elif ((start <= istart && end >= iend)); then
		                    :
		                elif ((end + 1 >= istart && end <= iend)); then
		                    end=$iend
		                elif ((start <= iend + 1 && start >= istart)); then
		                    start=$istart
		                else
		                    newhunks+=("$ihunk")
		                    covered_lines_count=$((covered_lines_count - istart + iend + 1))
		                fi
		
		                i=$((i + 1))
		            done
		
		            if ((placed == 0)); then
		                if ((start == end)); then
		                    newhunks+=("$start")
		                    covered_lines_count=$((covered_lines_count + 1))
		                else
		                    newhunks+=("$start-$end")
		                    covered_lines_count=$((covered_lines_count - start + end + 1))
		                fi
		            fi
		
		            exhunks=("${newhunks[@]}")
		        done
		
		        : "$(printf ',%s' "${newhunks[@]}")"
		        cov_hunks[$index]=${_:1}
		        cov_lines[$index]=${covered_lines_count}
		    else
		        cov_files+=("$filename")
		        cov_hunks+=("$covered_hunks")
		        cov_lines+=("$covered_lines_count")
		        cov_file_lines+=("$total_lines_count")
		    fi
		}
		
		__bgen_test_reverse_lines() {
		    tac 2>/dev/null || tail -r 2>/dev/null || gtac
		}
		
		__bgen_test_count_lines() {
		    if wc -l <<<"$1"; then
		        return
		    fi
		
		    # calculate number of lines by removing all \n chars
		    # and getting character difference from the original string
		    : "${1//$'\n'/}"
		    echo $((${#1} - ${#_} + 1))
		}
		
		# takes trailing lines (ending with backslash) into account
		# in the length of trails map
		__bgen_test_normalize_trails_map() {
		    local current_trail=0
		    local trail_start=0
		
		    local line_nr
		    line_nr=$(__bgen_test_count_lines "$__BGEN_TEST_SOURCE")
		    while IFS= read -r line; do
		        if ((trails_map[line_nr])); then
		            current_trail=$((line_nr))
		            trail_start=$((line_nr - trails_map[line_nr]))
		        elif ((trail_start != 0 && line_nr < trail_start)); then
		            current_trail=0
		            trail_start=0
		            line_nr=$((line_nr - 1))
		            continue
		        fi
		
		        if ((line_nr <= current_trail && line_nr > trail_start)) \
		            && [[ "$line" =~ [\\]$ ]] && ! [[ "$line" =~ \\[\\]$ ]]; then
		            # shift all lines in this trail by 1
		            trail_start=$((trail_start - 1))
		            for ((i = trail_start + 1; i <= line_nr; i++)); do
		                if [[ "${coverage_map[$((i + 1))]+x}" ]]; then
		                    coverage_map[$i]=$((coverage_map[i + 1]))
		                else
		                    unset "coverage_map[$i]"
		                fi
		            done
		            unset "coverage_map[$line_nr]"
		        fi
		
		        line_nr=$((line_nr - 1))
		    done < <(__bgen_test_reverse_lines <<<"$__BGEN_TEST_SOURCE")
		}
		
		__bgen_test_extend_coverage_hunk() {
		    if [[ "$hunk_start" ]]; then
		        hunk_end=$((hunk_end + pending_lines + 1))
		    else
		        local line_nr_offset=$((line_nr - file_start - line_offset))
		        hunk_start=$((line_nr_offset - pending_lines))
		        hunk_end=$line_nr_offset
		    fi
		    file_covered_lines=$((file_covered_lines + pending_lines + 1))
		}
		
		__bgen_test_close_coverage_hunk() {
		    if [[ "$hunk_start" ]]; then
		        if [[ "$hunk_start" == "$hunk_end" ]]; then
		            covered_hunks+=("$hunk_start")
		        else
		            covered_hunks+=("$hunk_start-$hunk_end")
		        fi
		
		        hunk_start=
		        hunk_end=
		    fi
		}
		
		__bgen_test_contains_str_start() {
		    local str=$1
		    if [[ "$str" != *[\'\"]* || "$str" =~ ^[[:space:]]*\# ]]; then
		        return 1
		    fi
		
		    local i=$str_search_offset
		    str_search_offset=0
		    quote_type=
		    while ((i < ${#str})); do
		        local char=${str:$i:1}
		        if [[ "$char" =~ [\'\"] ]] && ( ((i == 0)) || [[ "${str:$((i - 1)):1}" != \\ ]]); then
		            if [[ ! "$quote_type" ]]; then
		                quote_type=$char
		            elif [[ "$char" == "$quote_type" ]]; then
		                quote_type=
		            fi
		        fi
		        i=$((i + 1))
		    done
		
		    [[ "$quote_type" ]]
		}
		
		__bgen_test_contains_str_end() {
		    local str=$1
		    local quote_type=$2
		
		    if ! [[ "$quote_type" && "$str" == *$quote_type* ]]; then
		        return 1
		    fi
		
		    : "${str%%[$quote_type]*}"
		    str_search_offset=$((${#_} + 1))
		}
		
		__bgen_test_contains_heredoc_start() {
		    local str=$1
		    if [[ "$str" != *[^\<]\<\<[-\"_[:alnum:]]* || "$str" =~ ^[[:space:]]*\# ]]; then
		        return 1
		    fi
		
		    : "${str##*[^<]<<}"
		    : "${_#\-}"
		    : "${_#\"}"
		    : "${_%%\"*}"
		    local token=$_
		    if ! [[ "$token" =~ [_[:alpha:]][_[:alnum:]]* ]]; then
		        return 1
		    fi
		    heredoc_token=$token
		}
		
		__bgen_test_contains_heredoc_end() {
		    local str=$1
		    local token=$2
		
		    [[ "$token" && "$str" =~ ^[$'\t']*"$token"$ ]]
		}
		
		__bgen_test_contains_array_start() {
		    local str=$1
		    if ! [[ "$str" =~ [_[:alnum:]]\=\( ]] || [[ "$str" =~ ^[[:space:]]*\# ]]; then
		        return 1
		    fi
		
		    local i=0
		    local open=0
		    local quote_type=
		    while ((i < ${#str})); do
		        if [[ "${str:$i:1}" =~ [\'\"] ]] && ( ((i == 0)) || [[ "${str:$((i - 1)):1}" != \\ ]]); then
		            if [[ ! "$quote_type" ]]; then
		                quote_type=${str:$i:1}
		            elif [[ "${str:$i:1}" == "$quote_type" ]]; then
		                quote_type=
		            fi
		        elif ((i > 2)) && [[ ! "$quote_type" ]]; then
		            if [[ "${str:$((i - 1)):2}" == '=(' && "${str:$((i - 2)):1}" != \\ ]]; then
		                open=1
		            elif [[ "${str:$i:1}" == ')' && "${str:$((i - 1))}" != \\ ]]; then
		                open=0
		            fi
		        fi
		        i=$((i + 1))
		    done
		
		    ((open))
		}
		
		__bgen_test_contains_array_end() {
		    [[ "$1" =~ ^[[:space:]]*\) ]]
		}
		
		# parses coverage map
		__bgen_test_parse_coverage_map() {
		    local current_file=${1:-}
		    local file_start=$line_nr
		    local line_offset=0
		
		    local file_covered_lines=0
		
		    local hunk_start=
		    local hunk_end=
		
		    local pending_lines=0 # lines that end with a backslash or $(
		    local covered_hunks=()
		    local is_prev_line_covered=1
		
		    local in_string=
		    local string_covered=0
		    local str_search_offset=0
		
		    local in_heredoc=
		    local in_array_decl=
		
		    local in_nocov=0
		
		    while IFS= read -r line; do
		        line_nr=$((line_nr + 1))
		
		        : "${line%${line##*[![:space:]]}}"  # strip any trailing whitespace if any
		        local line=${_#${_%%[![:space:]]*}} # strip leading whitepsace if any
		
		        if ((${BGEN_COVERAGE_EXPERIMENTAL:-})); then
		            if __bgen_test_contains_str_end "$line" "$in_string"; then
		                in_string=
		                if ((string_covered)); then
		                    __bgen_test_extend_coverage_hunk
		                    pending_lines=0
		                    continue
		                fi
		                string_covered=0
		            fi
		
		            if __bgen_test_contains_heredoc_end "$line" "$in_heredoc"; then
		                in_heredoc=
		            fi
		
		            if ((in_array_decl)) && __bgen_test_contains_array_end "$line"; then
		                in_array_decl=
		            fi
		
		            if [[ "$in_string" || "$in_heredoc" || "$in_array_decl" ]]; then
		                if ((coverage_map[line_nr])); then
		                    __bgen_test_extend_coverage_hunk
		                    is_prev_line_covered=1
		                    pending_lines=0
		                else
		                    pending_lines=$((pending_lines + 1))
		                fi
		                continue
		            fi
		
		            local heredoc_token=
		            if __bgen_test_contains_heredoc_start "$line"; then
		                if ((coverage_map[line_nr])); then
		                    __bgen_test_extend_coverage_hunk
		                    is_prev_line_covered=1
		                    pending_lines=0
		                else
		                    pending_lines=$((pending_lines + 1))
		                fi
		                in_heredoc=$heredoc_token
		                continue
		            fi
		
		            local quote_type=
		            if __bgen_test_contains_str_start "$line"; then
		                if ((coverage_map[line_nr])); then
		                    __bgen_test_extend_coverage_hunk
		                    is_prev_line_covered=1
		                    string_covered=1
		                    pending_lines=0
		                else
		                    pending_lines=$((pending_lines + 1))
		                fi
		                in_string=$quote_type
		                continue
		            fi
		
		            if __bgen_test_contains_array_start "$line"; then
		                if ((coverage_map[line_nr])); then
		                    __bgen_test_extend_coverage_hunk
		                    is_prev_line_covered=1
		                    pending_lines=0
		                else
		                    pending_lines=$((pending_lines + 1))
		                fi
		                in_array_decl=1
		                continue
		            fi
		
		            # lines ending with $(
		            if [[ "$line" =~ ([^\\]|^)\$\($ ]]; then
		                if ((coverage_map[line_nr])); then
		                    __bgen_test_extend_coverage_hunk
		                    is_prev_line_covered=1
		                    pending_lines=0
		                else
		                    pending_lines=$((pending_lines + 1))
		                fi
		                continue
		            fi
		        fi
		
		        if [[ "$line" =~ ^\#[[:space:]]BGEN__END[[:space:]] ]]; then
		            pending_lines=0
		            __bgen_test_close_coverage_hunk
		
		            local file_line_count=$((line_nr - file_start - line_offset - 1))
		
		            if [[ "$current_file" == "$PWD"* ]]; then
		                __bgen_test_add_file_report "$current_file" \
		                    "$(__bgen_test_join_by , "${covered_hunks[@]}")" \
		                    "$file_covered_lines" "$file_line_count"
		            fi
		
		            total_covered=$((total_covered + file_covered_lines))
		            total_lines=$((total_lines + file_line_count))
		
		            return
		        fi
		
		        if [[ "$line" =~ ^\#[[:space:]]BGEN__BEGIN[[:space:]] ]]; then
		            : "${line#*BGEN__BEGIN[[:space:]]}"
		            local file=${_#${_%%[![:space:]]*}}
		
		            local start_line_nr=$line_nr
		            __bgen_test_parse_coverage_map "$file"
		            line_offset=$((line_offset + line_nr - start_line_nr))
		
		            __bgen_test_extend_coverage_hunk
		            pending_lines=0
		            continue
		        fi
		
		        if [[ "$current_file" ]]; then
		            local skip_line=0
		            if __bgen_is_line_covered "$line_nr" "$line"; then
		                __bgen_test_extend_coverage_hunk
		                is_prev_line_covered=1
		            elif ((skip_line)); then
		                continue
		            else
		                __bgen_test_close_coverage_hunk
		                is_prev_line_covered=0
		            fi
		        fi
		
		        # reset the pending lines count
		        pending_lines=0
		    done
		}
		
		# print final coverage report
		__bgen_test_make_coverage_report() {
		    local html_report=
		    local coverage_report=()
		
		    local cov_files=()
		    local cov_hunks=()
		    local cov_lines=()
		    local cov_file_lines=()
		
		    local total_covered=0
		    local total_lines=0
		
		    echo "    Generating coverage report, please wait..."
		
		    local line_nr=0
		    __bgen_test_normalize_trails_map
		    __bgen_test_parse_coverage_map <<<"$__BGEN_TEST_SOURCE"
		
		    if ((${#cov_files[@]})); then
		        total_covered=0
		        total_lines=0
		
		        local i=0
		        while ((i < ${#cov_files[@]})); do
		            local filename=${cov_files[$i]}
		            local hunks=${cov_hunks[$i]}
		            local covered_lines_count=${cov_lines[$i]}
		            local total_lines_count=${cov_file_lines[$i]}
		
		            local percent=$((100 * covered_lines_count / total_lines_count))
		            local filename_short=${filename/$PWD\//}
		
		            if ((percent >= BGEN_COVERAGE_H_THRESHOLD)); then
		                local coverage_rating=h
		                local coverage_color=$__BGEN_TEST_COL_SUCCESS
		            elif ((percent >= BGEN_COVERAGE_M_THRESHOLD)); then
		                local coverage_rating=m
		                local coverage_color=$__BGEN_TEST_COL_WARNING
		            else
		                local coverage_rating=l
		                local coverage_color=$__BGEN_TEST_COL_DANGER
		            fi
		
		            if [[ "$BGEN_HTML_REPORT_FILE" ]]; then
		                local file_id=${filename_short//[![:alnum:]-_]/_}
		
		                : "$(<"$filename")"
		                : "${_//</&lt;}"
		                local code=${_//>/&gt;}
		
		                : "${__BGEN_COVERAGE_HTML_FILE//__COVERAGE_FILE_NAME__/$filename_short}"
		                : "${_//__COVERAGE_FILE_ID__/$file_id}"
		                : "${_//__COVERAGE_FILE_COVERED__/$covered_lines_count}"
		                : "${_//__COVERAGE_FILE_LINES__/$total_lines_count}"
		                : "${_//__COVERAGE_FILE_PERCENT__/$percent}"
		                : "${_//__COVERAGE_FILE_RATING__/$coverage_rating}"
		                : "${_//__COVERAGE_FILE_HUNKS__/$hunks}"
		                local html="${_//__COVERAGE_FILE_CODE__/$code}"
		
		                html_report+=$html
		            fi
		
		            local report_line
		            report_line="$(
		                printf '%s %b(%s/%s)\t%b%3s%%%b' "$filename_short" \
		                    "$__BGEN_TEST_COL_TRIVIAL" "$covered_lines_count" \
		                    "$total_lines_count" "$coverage_color" "$percent" "$__BGEN_TEST_COL_RESET"
		            )"
		
		            coverage_report+=("$report_line")
		
		            total_covered=$((total_covered + covered_lines_count))
		            total_lines=$((total_lines + total_lines_count))
		            i=$((i + 1))
		        done
		    else
		        echo "    Nothing to cover :/"
		        return
		    fi
		
		    local coverage_percent
		    coverage_percent=$((100 * total_covered / total_lines))
		    if ((coverage_percent >= BGEN_COVERAGE_H_THRESHOLD)); then
		        local coverage_color=$__BGEN_TEST_COL_SUCCESS
		        local coverage_rating=h
		    elif ((coverage_percent >= BGEN_COVERAGE_M_THRESHOLD)); then
		        local coverage_color=$__BGEN_TEST_COL_WARNING
		        local coverage_rating=m
		    else
		        local coverage_color=$__BGEN_TEST_COL_DANGER
		        local coverage_rating=l
		    fi
		
		    # print file reports
		    printf '\e[1A\e[2K'
		    __bgen_test_format_columns < <(
		        printf '  \t%s\n' "${coverage_report[@]}"
		        printf '\n  \tTOTAL COVERED %b(%s/%s)\t%b%3s%%%b\n' \
		            "$__BGEN_TEST_COL_TRIVIAL" "$total_covered" "$total_lines" \
		            "$coverage_color" "$coverage_percent" "$__BGEN_TEST_COL_RESET"
		    )
		
		    # save html report
		    if [[ "$BGEN_HTML_REPORT_FILE" ]]; then
		        local coverage_date
		        coverage_date=$(date)
		
		        : "${__BGEN_COVERAGE_HTML_HEADER//__COVERAGE_DATE__/$coverage_date}"
		        : "${_//__COVERAGE_TITLE__/Coverage report}"
		        : "${_//__COVERAGE_TOTAL_COVERED__/$total_covered}"
		        : "${_//__COVERAGE_TOTAL_LINES__/$total_lines}"
		        : "${_//__COVERAGE_TOTAL_PERCENT__/$coverage_percent}"
		        local html_header="${_//__COVERAGE_TOTAL_RATING__/$coverage_rating}"
		
		        local final_html_report=$html_header
		        final_html_report+=$html_report
		        final_html_report+=$__BGEN_COVERAGE_HTML_FOOTER
		        echo "$final_html_report" >"$BGEN_HTML_REPORT_FILE"
		
		        printf "\n    %bCoverage report file: %s%b\n" \
		            "$__BGEN_TEST_COL_TITLE" "$BGEN_HTML_REPORT_FILE" "$__BGEN_TEST_COL_RESET"
		    fi
		}
		
		# formats tab separated stdin entries as columns
		# shellcheck disable=SC2120
		__bgen_test_format_columns() {
		    local separator=${1:-  }
		
		    if column -o "$separator" -s $'\t' -t -L 2>/dev/null; then
		        return
		    fi
		
		    # parse manually
		    local column_widths=()
		    local lines=()
		    local cell
		    local cell_width
		
		    # for each column find the longest cell
		    while IFS= read -r line; do
		        if [[ "$line" ]]; then
		            local i=0
		            while IFS= read -r cell; do
		                cell_width="${#cell}"
		                if ((cell_width > column_widths[i])); then
		                    column_widths[$i]="$cell_width"
		                fi
		                i=$((i + 1))
		            done <<<"${line//$'\t'/$'\n'}"
		        fi
		
		        lines+=("$line")
		    done
		
		    # generate a printf string such as it can print each cells at a given width
		    local printf_query
		    printf_query=$(printf -- "$separator%%-%ss" "${column_widths[@]}")
		    for line in "${lines[@]-}"; do
		        if [[ ! "$line" ]]; then
		            echo
		            continue
		        fi
		
		        cells=()
		        while IFS= read -r cell; do
		            cells+=("$cell")
		        done <<<"${line//$'\t'/$'\n'}"
		        # shellcheck disable=SC2059
		        printf "${printf_query/$separator/}\n" "${cells[@]}"
		    done
		}
		
		__bgen_test_run_single() {
		    local test_func=$1
		
		    local stdout_file
		    stdout_file=$(mktemp)
		    # shellcheck disable=SC2064
		    trap "rm '$stdout_file'" EXIT
		
		    local stderr_file env_dir
		    stderr_file=$(mktemp)
		    # shellcheck disable=SC2064
		    trap "rm '$stderr_file'" EXIT
		
		    local env_dir
		    env_dir=$(mktemp -d)
		    # shellcheck disable=SC2064
		    trap "rm -rf '$env_dir'" EXIT
		    export __bgen_env_dir="$env_dir"
		
		    # we don't want this subshell to cause the entire test to fail
		    # so we relax bash options until we get a status code
		    set +o errexit +o errtrace +o nounset +o pipefail
		    (
		        # used to track sub-subshells
		        export __bgen_test_main_subshell=$BASH_SUBSHELL
		
		        # Used to track coverage
		        __bgen_test_covered_lines=()
		
		        # enable some bash options to allow error checking
		        set -o errexit -o errtrace -o nounset -o pipefail -o functrace
		
		        # set up some hooks to print original error lines and files
		        trap '__bgen_test_debug_handler "$?" "$LINENO" "$BASH_COMMAND" "$_"' DEBUG
		        trap 'trap - DEBUG; __bgen_test_error_handler "$LINENO"' ERR
		        trap 'trap - DEBUG; __bgen_test_exit_handler "$LINENO"' EXIT
		
		        # call our test function
		        "$test_func"
		
		        # workaround to check if function didn't end prematurely
		        # bash 3.2 exists with rc=0 on unset variables :/
		        __func_finished_successfully=1
		    ) >"$stdout_file" 2>"$stderr_file"
		    local err=$?
		    set -o errexit -o errtrace -o nounset -o pipefail
		
		    # Merge covered lines into the global list
		    for env_file in "$env_dir"/*; do
		        if [[ "$env_file" == "$env_dir/*" ]]; then
		            break
		        fi
		
		        local env_arrays
		        env_arrays=$(<"$env_file")
		        if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4))); then
		            # workaround bash <4.4 quoting the content of the variables in declare's output
		            local intermediary_coverage_map=()
		            local intermediary_trails_map=()
		
		            # use variables to escape single quotes and newlines in var expansion
		            local affect_intermediary_coverage_map="'intermediary_coverage_map+="
		            local affect_intermediary_trails_map="'intermediary_trails_map+="
		            local newline_sub="'"$'\n'"'"
		            local newline=$'\n'
		
		            # also these versions concat array elements instead of replacing them
		            # so we unset existing values before setting new ones
		            : "${env_arrays//declare -a __bgen_test_covered_lines=\'/$affect_intermediary_coverage_map}"
		            : "${_//declare -a __bgen_test_subshell_trails=\'/$affect_intermediary_trails_map}"
		            : "${_//$newline_sub/$newline}"
		            eval "$(eval "echo $_")"
		            for index in "${!intermediary_coverage_map[@]}"; do
		                unset "coverage_map[$index]"
		            done
		            for index in "${!intermediary_trails_map[@]}"; do
		                unset "trails_map[$index]"
		            done
		
		            local affect_coverage_map="'coverage_map+="
		            local affect_trails_map="'trails_map+="
		            : "${env_arrays//declare -a __bgen_test_covered_lines=\'/$affect_coverage_map}"
		            : "${_//declare -a __bgen_test_subshell_trails=\'/$affect_trails_map}"
		            : "${_//$newline_sub/$newline}"
		            eval "$(eval "echo $_")"
		        else
		            : "${env_arrays//declare -a __bgen_test_covered_lines=/coverage_map+=}"
		            : "${_//declare -a __bgen_test_subshell_trails=/trails_map+=}"
		            eval "$_"
		        fi
		    done
		
		    # print a dot or F depending on test status
		    if ((err)); then
		        printf "%bF%b" "$__BGEN_TEST_COL_DANGER" "$__BGEN_TEST_COL_RESET"
		        failed_tests_funcs+=("$test_func")
		    else
		        passed_test_count=$((passed_test_count + 1))
		        printf "%b.%b" "$__BGEN_TEST_COL_SUCCESS" "$__BGEN_TEST_COL_RESET"
		    fi
		
		    : "${BGEN_NO_CAPTURE:=}"
		    if ((err == 0 && BGEN_NO_CAPTURE == 0)); then
		        return
		    fi
		
		    if [[ -s "$stdout_file" || -s "$stderr_file" ]]; then
		        local report
		        report=$(
		            printf '\n%b----- %s ----- %b\n' "$__BGEN_TEST_COL_FILENAME" "$test_func" "$__BGEN_TEST_COL_RESET"
		
		            if [[ -s "$stdout_file" ]]; then
		                printf "%bstdout:%b\n" "$__BGEN_TEST_COL_TRIVIAL" "$__BGEN_TEST_COL_RESET"
		                cat "$stdout_file"
		                echo
		            fi
		
		            if [[ -s "$stderr_file" ]]; then
		                printf "%bstderr:%b\n" "$__BGEN_TEST_COL_TRIVIAL" "$__BGEN_TEST_COL_RESET"
		                cat "$stderr_file"
		                echo
		            fi
		        )
		        test_reports+=("$report")
		    fi
		}
		
		if [[ "$NO_COLOR" ]]; then
		    __BGEN_TEST_COL_DANGER=""
		    __BGEN_TEST_COL_WARNING=""
		    __BGEN_TEST_COL_SUCCESS=""
		    __BGEN_TEST_COL_TITLE=""
		    __BGEN_TEST_COL_FILENAME=""
		    __BGEN_TEST_COL_RESET=""
		else
		    __BGEN_TEST_COL_DANGER="\e[31m"
		    __BGEN_TEST_COL_WARNING="\e[33m"
		    __BGEN_TEST_COL_SUCCESS="\e[32m"
		    __BGEN_TEST_COL_TITLE="\e[36m"
		    __BGEN_TEST_COL_FILENAME="\e[33m"
		    __BGEN_TEST_COL_TRIVIAL="\e[90m"
		    __BGEN_TEST_COL_RESET="\e[0m"
		fi
		
		read -rd "" __BGEN_COVERAGE_HTML_HEADER <<-"EOF" || :
		<html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>__COVERAGE_TITLE__</title>
		
		    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-coy.min.css"
		        integrity="sha512-CKzEMG9cS0+lcH4wtn/UnxnmxkaTFrviChikDEk1MAWICCSN59sDWIF0Q5oDgdG9lxVrvbENSV1FtjLiBnMx7Q=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css"
		        integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.css"
		        integrity="sha512-nXlJLUeqPMp1Q3+Bd8Qds8tXeRVQscMscwysJm821C++9w6WtsFbJjPenZ8cQVMXyqSAismveQJc0C1splFDCA=="
		        crossorigin="anonymous" />
		    <style>
		        body {
		            font-family: monospace;
		        }
		        pre[class*=language-]:before, pre[class*=language-]:after {
		            display: none;
		            content: unset;
		        }
		        .coverage-file pre {
		            margin-bottom: 1rem;
		            font-size: 0.7rem;
		        }
		        .line-highlight {
		            background: linear-gradient(to right,hsl(100deg 89% 63% / 12%) 70%,hsl(105deg 86% 63% / 22%));
		        }
		        .coverage-percent {
		            color: white;
		            padding: 0 0.1rem;
		            display: inline-block;
		            text-align: center;
		            min-width: 2.2rem;
		        }
		        .coverage-rating-h .coverage-percent {
		            background-color: green;
		        }
		        .coverage-rating-m .coverage-percent {
		            background-color: orange;
		        }
		        .coverage-rating-l .coverage-percent {
		            background-color: red;
		        }
		    </style>
		</head>
		<body>
		<div class="coverage-header coverage-rating-__COVERAGE_TOTAL_RATING__">
		    <div class="stats">
		        <span class="coverage-percent">__COVERAGE_TOTAL_PERCENT__%</span>
		        Total (__COVERAGE_TOTAL_COVERED__/__COVERAGE_TOTAL_LINES__)
		    </div>
		    <div class="date">
		        Date: __COVERAGE_DATE__
		        <a href="#" class="collapse-all">Collapse All</a>
		        <a href="#" class="expand-all">Expand All</a>
		    </div>
		    <hr/>
		</div>
		EOF
		
		read -rd "" __BGEN_COVERAGE_HTML_FILE <<-"EOF" || :
		<details class="coverage-file coverage-rating-__COVERAGE_FILE_RATING__" id="__COVERAGE_FILE_ID__" open>
		    <summary class="coverage-file-title">
		        <span class="coverage-percent">__COVERAGE_FILE_PERCENT__%</span>
		        <span class="coverage-file-name">__COVERAGE_FILE_NAME__</span>
		        <span class="coverage-covered-lines">(<span
		                class="covered"
		            >__COVERAGE_FILE_COVERED__</span>/<span
		                class="total"
		            >__COVERAGE_FILE_LINES__</span>)<span>
		    </summary>
		    <pre
		        class="line-numbers" id="pre-__COVERAGE_FILE_ID__" data-line="__COVERAGE_FILE_HUNKS__"
		    ><code class="language-bash">__COVERAGE_FILE_CODE__</code></pre>
		</details>
		EOF
		
		read -rd "" __BGEN_COVERAGE_HTML_FOOTER <<-"EOF" || :
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"
		    integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js"
		    integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js"
		    integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.js"
		    integrity="sha512-MGMi0fbhnsk/a/9vCluWv3P4IOfHijjupSoVYEdke+QQyGBOAaXNXnwW6/IZSH7JLdknDf6FL6b57o+vnMg3Iw=="
		    crossorigin="anonymous"></script>
		<script>
		(function() {
		    function collapseAll() {
		        var elems = document.querySelectorAll('details[open]');
		        for (var i = 0; i < elems.length; ++i) {
		            elems[i].open = false;
		        }
		    }
		    function expandAll() {
		        var elems = document.querySelectorAll('details');
		        for (var i = 0; i < elems.length; ++i) {
		            elems[i].open = true;
		        }
		    }
		
		    var collapseBtn = document.querySelector('.collapse-all');
		    if (collapseBtn) {
		        collapseBtn.addEventListener('click', function(e) {
		            e.preventDefault();
		            collapseAll();
		        })
		    }
		
		    var expandBtn = document.querySelector('.expand-all');
		    if (expandBtn) {
		        expandBtn.addEventListener('click', function(e) {
		            e.preventDefault();
		            expandAll();
		        })
		    }
		
		    // collapsing using js because line highlighter doesn't work on collapsed details blocks
		    setTimeout(collapseAll);
		})();
		</script>
		</body>
		</html>
		EOF
		
		__bgen_test_entrypoint "$@"
		BGEN_EOF_11074_32198
# BGEN__INCLUDE_STR_END
    process_input <<<"$bootstrap"
}

collect_testfiles_in_dir() {
    local dir=$1

    for file in "$dir"/*; do
        # ${file##*/} keeps only what's after the last slash (aka the basename)
        if [[ "${file##*/}" != "_"* ]]; then
            test_files+=("$file")
        fi
    done
}
# BGEN__END /home/sdrm/projects/bgen/src/tests.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/install.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/barg/lib/barg.sh

command_install() {
    local should_exit=
    local should_exit_err=0
    barg.parse "$@"
    if ((should_exit)); then
        return "$should_exit_err"
    fi

    if ! type -p bpkg >/dev/null 2>&1; then
        echo "bpkg is not installed"
    fi

    bpkg_cmd="bpkg"

    local build_deps=()
    read_project_meta

    for dep in "${build_deps[@]}"; do
        butl.log_info "Installing $dep"

        "$bpkg_cmd" install "$dep"
    done
}
# BGEN__END /home/sdrm/projects/bgen/src/install.sh

# entrypoint
bgen() {
    barg.subcommand build command_build "builds the project"
    barg.subcommand run command_run "runs the project"
    barg.subcommand test command_test "runs tests"
    barg.subcommand install command_install "install project dependencies"

    local subcommand=
    local subcommand_args=()

    local should_exit=
    local should_exit_err=0
    barg.parse "$@"
    if ((should_exit)); then
        return "$should_exit_err"
    fi

    "$subcommand" "${subcommand_args[@]}"
}

[[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]] || bgen "$@"
