#!/usr/bin/env bash

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in case mysqldump fails (but gzip succeeds) in $(mysqldump | gzip)
set -o pipefail
# Turn on traces, useful for debugging. Set _XTRACE to enable
[[ "${_XTRACE:-}" ]] && set -o xtrace

# check whether script is source or directly executed
if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
    __process__="$__BGEN_PIPE_SOURCE__"
elif [[ "${BASH_SOURCE+x}" ]]; then
    __process__="${BASH_SOURCE[0]}"
else
    __process__="$0"
fi

if [[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]]; then
    __main__= # false
    # shellcheck disable=SC2154
    if [[ "${__usage__+x}" ]]; then
        if [[ "${BASH_SOURCE[1]}" = "${0}" ]]; then
            __main__=1 # true
        fi

        __process__="${BASH_SOURCE[1]}"
    fi
else
    # shellcheck disable=SC2034
    __main__=1 # true
    [[ "${__usage__+x}" ]] && unset -v __usage__
fi

# Set magic variables for current file, directory, os, etc.
__dir__="$(cd "$(dirname "${__process__}")" && pwd)"
__file__="${__dir__}/$(basename "${__process__}")"
# shellcheck disable=SC2034,SC2015
__base__="$(basename "${__file__}" .sh)"
# shellcheck disable=SC2034,SC2015
if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
    __invocation__="${__BGEN_PIPE_SOURCE__}"
else
    __invocation__="$(printf %q "${__file__}")"
fi

# Define the environment variables (and their defaults) that this script depends on
LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected


# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/bgen/src/build.sh
# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/bgen/src/utils.sh
# BGEN__SHEBANG_REMOVED

bail() {
    local err_message="$1"
    local err_code="${2:-1}"

    echo "$err_message" >&2
    exit "$err_code"
}

trim_str() {
    : "${1#${1%%[![:space:]]*}}"
    echo "${_%${_##*[![:space:]]}}"
}
# BGEN__END /home/sdrm/projects/bgen/src/utils.sh

build_project() {
    # save it in a temp file first
    local tmp_file
    tmp_file=$(mktemp /tmp/bgen.XXXXXXXXXX)
    # shellcheck disable=SC2064
    trap "rm '$tmp_file' >/dev/null || true" exit

    # build the project
    build_project_to_stdout >"$tmp_file"

    # shellcheck disable=SC1007
    local output_file=""
    read_project_meta

    # get output_file's directory
    : "${output_file%/*}"
    local output_dir="${_:-/}"

    # make sure the output's directory exists
    if [[ "$output_dir" && "$output_dir" != "." ]]; then
        mkdir -p "$output_dir"
    fi

    # copy it to the real output dir and make it executable
    cp "$tmp_file" "$output_file"
    chmod +x "$output_file"
}

build_project_to_stdout() {
    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    local imported_files=()

    local project_root=
    local project_name=
    local header_file=
    local entrypoint_file=
    local entrypoint_func=
    local shebang_string=
    local import_paths=
    read_project_meta

    # build the project
    echo_header
    process_file "$entrypoint_file"
    echo_entrypoint_call
}

build_tests_to_stdout() {
    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    local imported_files=()

    local project_root=
    local project_name=
    local header_file=
    local tests_dir=
    local shebang_string=
    local import_paths=
    local entrypoint_file=
    local entrypoint_func=
    read_project_meta

    # make sure tests directory exists
    if ! [[ -d "$tests_dir" ]]; then
        echo "tests directory '$tests_dir' does not exist" >&2
        exit 1
    fi

    local test_files=()
    local test_funcs=()
    local failed=0
    local no_capture="${BGEN_NO_CAPTURE:-0}"
    local coverage="${BGEN_COVERAGE:-0}"
    local coverage_file="${BGEN_HTML_REPORT_FILE:-}"
    while (($#)); do
        case "$1" in
        -k)
            test_funcs+=("$2")
            shift 2
            ;;
        -k=*)
            test_funcs+=("${1/-k=/}")
            shift
            ;;
        -O | --no-capture)
            no_capture=1
            shift
            ;;
        -c | --coverage)
            coverage=1
            shift
            ;;
        -h | --html-report)
            coverage=1
            coverage_file="$2"
            shift 2
            ;;
        -h=*)
            coverage=1
            coverage_file="${1/-h=/}"
            shift
            ;;
        --html-report=*)
            coverage=1
            coverage_file="${1/--html-report=/}"
            shift
            ;;
        *)
            local file="$1"
            shift

            if [[ -f "$file" ]]; then
                test_files+=("$file")
                continue
            fi

            echo "test file '$file' does not exist" >&2
            failed=1
            ;;
        esac
    done

    if ((failed)); then
        exit 1
    elif ! ((${#test_files[@]})); then
        for file in "$tests_dir"/*; do
            # ${file##*/} keeps only what's after the last slash (aka the basename)
            if [[ "${file##*/}" != "_"* ]]; then
                test_files+=("$file")
            fi
        done
    fi

    # build the tests file
    echo_header

    # pre-including the project for tests to have better coverage reports
    # if there's no entrypoint function, we assume the entrypoint file
    # runs actual code and that can cause problems during tests
    if [[ "$entrypoint_func" ]]; then
        bgen_import "$entrypoint_file" || { check && true; }
    fi

    for test_file in "${test_files[@]}"; do
        [[ -f "$test_file" ]] || continue

        bgen_import "$test_file" || { check && true; }
    done

    if ((${#test_funcs[@]})); then
        echo "__BGEN_TEST_FUNCS__=("
        printf '    %q\n' "${test_funcs[@]}"
        echo ")"
    fi

    echo "BGEN_NO_CAPTURE=$no_capture"
    echo "BGEN_COVERAGE=$coverage"
    printf "BGEN_HTML_REPORT_FILE=%q\n\n" "$coverage_file"

    local testlib
# BGEN__INCLUDE_STR_BEGIN
    read -r -d '' testlib <<-"BGEN_EOF_1664727455" || :
		#!/usr/bin/env bash
		
		bgen:import src/lib/asserts.sh
		
		__bgen_test_entrypoint() {
		    local failed_tests_funcs=()
		    local test_reports=()
		
		    local coverage_map=()
		    local trails_map=()
		
		    # linemap shows at what lines each file starts and ends
		    if [[ ! "${__BGEN_TEST_LINEMAP:-}" ]]; then
		        local linemap=()
		        local line_nr=0
		        while IFS= read -r line; do
		            line_nr=$((line_nr + 1))
		
		            local line="${line#${line%%[![:space:]]*}}" # strip leading whitepsace if any
		            if [[ "$line" =~ ^\#[[:space:]]BGEN__ ]]; then
		                linemap+=("$line_nr ${line:2}")
		            fi
		        done <<<"$BASH_EXECUTION_STRING"
		
		        local linemap_str
		        linemap_str="$(__bgen_test_join_by $'\n' "${linemap[@]}")"
		        export __BGEN_TEST_LINEMAP="$linemap_str"
		    fi
		
		    # loop over test functions
		    printf "%bRunning tests...%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		    local passed_test_count=0
		    local total_test_count=0
		    if declare -p __BGEN_TEST_FUNCS__ >/dev/null 2>&1; then
		        # bgen test created a variable with specific tests to run
		        for test_func in "${__BGEN_TEST_FUNCS__[@]}"; do
		            __bgen_test_run_single "$test_func"
		            total_test_count=$((total_test_count + 1))
		        done
		    else
		        # no specific tests to run, find and run all tests that start with test_xxxx
		        while IFS= read -r line; do
		            if [[ "$line" == "declare -f test_"[[:alnum:]]* ]]; then
		                local test_func="${line#${line%%test_*}}"
		                __bgen_test_run_single "$test_func"
		                total_test_count=$((total_test_count + 1))
		            fi
		        done < <(declare -F)
		    fi
		
		    if ((total_test_count == 0)); then
		        echo "    No tests to run :("
		    else
		        # return to line after the dots
		        echo
		    fi
		
		    if (("${#test_reports[@]}")); then
		        for test_report in "${test_reports[@]}"; do
		            echo "$test_report"
		        done
		        printf '\n%b-----%b' "$__BGEN_TEST_COL_FILENAME" "$__BGEN_TEST_COL_RESET"
		    fi
		
		    if (("${#failed_tests_funcs[@]}")); then
		        printf "\n%bFailed tests:%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		        for test_func in "${failed_tests_funcs[@]}"; do
		            echo "    $test_func"
		        done
		    fi
		
		    # report on coverage if requested
		    : "${BGEN_COVERAGE:=0}"
		    : "${BGEN_HTML_REPORT_FILE:=}"
		    : "${BGEN_COVERAGE_M_THRESHOLD:=60}"
		    : "${BGEN_COVERAGE_H_THRESHOLD:=85}"
		    if ((BGEN_COVERAGE)); then
		        printf "\n%bCoverage:%b\n" "$__BGEN_TEST_COL_TITLE" "$__BGEN_TEST_COL_RESET"
		        __bgen_test_make_coverage_report
		    fi
		
		    if ((total_test_count > 0)); then
		        local n_tests
		        if ((total_test_count == 1)); then
		            n_tests="1 test"
		        else
		            n_tests="$(printf '%s tests' "$total_test_count")"
		        fi
		
		        # exit with error if any test failed
		        if (("${#failed_tests_funcs[@]}")); then
		            printf '\n%b%s/%s passed successfully%b\n' \
		                "$__BGEN_TEST_COL_DANGER" "$passed_test_count" "$n_tests" "$__BGEN_TEST_COL_RESET"
		            exit 1
		        else
		            printf '\n%b%s passed successfully %s%b\n' \
		                "$__BGEN_TEST_COL_SUCCESS" "$n_tests" "☆*･゜ﾟ･*(^O^)/*･゜ﾟ･*☆" "$__BGEN_TEST_COL_RESET"
		        fi
		    fi
		}
		
		# requires 2 variables: source_file and source_line_nr to be declared
		__bgen_test_get_source_line() {
		    local bgen_line="$1"
		
		    # stacks to keep track of...
		    local files_stack=("UNKNOWN_FILE") # which file we're currently processing
		    local line_nrs_stack=(0)           # the start line number of the file
		    local offsets_stack=(0)            # how much lines should we offset from this file's linecount
		
		    while IFS= read -r line; do
		        # parse the line number
		        local line="${line#${line%%[![:space:]]*}}" # strip leading whitespace if any
		        local line_nr="${line%%[[:space:]]*}"       # strip everything from the first space
		
		        if ((line_nr > bgen_line)); then
		            break
		        fi
		
		        # bash 3.2 seems to complain when i use case .. in .. esac here
		        if [[ "$line" =~ ^[[:digit:]]+[[:space:]]+BGEN__BEGIN[[:space:]]+ ]]; then
		            : "${line#*BGEN__BEGIN[[:space:]]}"
		            local file="${_#${_%%[![:space:]]*}}"
		
		            # add values related to this file to the new stack
		            files_stack=("$file" "${files_stack[@]}")
		            line_nrs_stack=("$line_nr" "${line_nrs_stack[@]}")
		            offsets_stack=(0 "${offsets_stack[@]}")
		        elif [[ "$line" =~ ^[[:digit:]]+[[:space:]]+BGEN__END[^[:alnum:]]+ ]]; then
		            local file_start_line_nr="${line_nrs_stack[0]}"
		            local file_lines=$((line_nr - file_start_line_nr))
		
		            # pop the first item from the stack
		            files_stack=("${files_stack[@]:1}")
		            line_nrs_stack=("${line_nrs_stack[@]:1}")
		            offsets_stack=("${offsets_stack[@]:1}")
		
		            # offset the previous item's lines with the linecount of this file
		            offsets_stack[0]=$((offsets_stack[0] + file_lines))
		        fi
		    done <<<"$__BGEN_TEST_LINEMAP"
		
		    if declare -p source_file 1>/dev/null 2>&1; then
		        source_file="${files_stack[0]/$PWD\//}"
		    fi
		
		    if declare -p source_line_nr 1>/dev/null 2>&1; then
		        source_line_nr=$((bgen_line - line_nrs_stack[0] - offsets_stack[0]))
		    fi
		}
		export -f __bgen_test_get_source_line
		
		# called when a test's subprocess exits with a non-zero return code
		__bgen_test_error_handler() {
		    local rc="$__bgen_test_current_rc"
		
		    # get error line number
		    if [[ "${__bgen_assert_line:-}" ]]; then
		        # bash versions <=4.3 only call the handler AFTER the returning function was left
		        # the workaround here is to have assert functions to keep track of the line they left at instead
		        local line_nr="$__bgen_assert_line"
		
		        # once again seems bash versions <=5.0 totally ignore the shebang's line
		        if ((BASH_VERSINFO[0] < 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] < 1))); then
		            line_nr=$((line_nr + 1))
		        fi
		    elif [[ "$__bgen_test_current_cmd" == "$__bgen_test_prev_cmd" ]]; then
		        # if we have two successive return commands, use the previous one's line
		        # workaround for when bash reports the return AFTER the returning to the parent function
		        local line_nr="$__bgen_test_prev_line_nr"
		    else
		        local line_nr="$__bgen_test_current_line_nr"
		
		        # bash 3.2 strangely uses the previous line for errors
		        if ((BASH_VERSINFO[0] < 4)); then
		            line_nr=$((line_nr + 1))
		        fi
		    fi
		
		    # prevent the exit_handler from outputting anything since it's also executed
		    __bgen_test_error_handled=1
		
		    # print the original source file and line number for easy debugging
		    local source_file=""
		    local source_line_nr=""
		    __bgen_test_get_source_line "$line_nr"
		    printf '%b%s:%s (status: %s)%b\n' \
		        "$__BGEN_TEST_COL_DANGER" "$source_file" "$source_line_nr" "$rc" "$__BGEN_TEST_COL_RESET" >&2
		
		    # exit with the same return code we came with
		    exit "$rc"
		}
		export -f __bgen_test_error_handler
		
		# called when a test's subprocess exits
		__bgen_test_exit_handler() {
		    local rc="$__bgen_test_current_rc"
		    local subshell_mode="${2:-}"
		
		    # save coverage lines into a file, only way to communicate them to the parent process
		    local env_file="$__bgen_env_dir/${BASH_SUBSHELL}_${RANDOM}_${RANDOM}.env"
		    declare -p __bgen_test_covered_lines >>"$env_file"
		
		    if [[ "${__bgen_test_subshell_line_count+x}" ]]; then
		        local __bgen_test_subshell_trails=()
		        __bgen_test_subshell_trails[$__bgen_test_subshell_line_end]=$((__bgen_test_subshell_line_count))
		        declare -p __bgen_test_subshell_trails >>"$env_file"
		    fi
		
		    # if the error handler was already triggered, don't do anything else here
		    if ((${__bgen_test_error_handled:-})) || ((subshell_mode)); then
		        exit "$rc"
		    fi
		
		    # more reliable than LINENO
		    local line_nr="$__bgen_test_prev_line_nr"
		
		    # get exit line number
		    if [[ "$rc" == 0 ]]; then
		        # workaround for bash <4.0 returning 0 on nounset errors
		        [[ "${__func_finished_successfully:-}" ]] && exit 0
		
		        # this is the same code bash returns on version 4+ in these cases
		        rc=127
		
		        if [[ "${__bgen_test_prev_line_nr:-}" ]]; then
		            line_nr=$((__bgen_test_prev_line_nr))
		        fi
		    elif [[ "${__bgen_test_prev_line_nr:-}" ]]; then
		        line_nr="$__bgen_test_prev_line_nr"
		    fi
		
		    # print the original source and line number for easy debugging
		    local source_file=""
		    local source_line_nr=""
		    __bgen_test_get_source_line "$line_nr"
		    printf '%b%s:%s (status: %s)%b\n' \
		        "$__BGEN_TEST_COL_DANGER" "$source_file" "$source_line_nr" "$rc" "$__BGEN_TEST_COL_RESET" >&2
		
		    # exit with the same return code we came with
		    exit "$rc"
		}
		export -f __bgen_test_exit_handler
		
		# called before each line, use to keep track of what lines
		# were executed, and which are the last 2 commands and their rc and line numbers
		# used for error reporting and code coverage
		__bgen_test_debug_handler() {
		    local rc="$1"
		    local line_nr="$2"
		    local cmd="$3"
		    local old_="$4"
		
		    # bash versions <5.1 don't seem to count the shebang in their line count
		    if ((BASH_VERSINFO[0] < 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] < 1))); then
		        line_nr=$((line_nr + 1))
		    fi
		
		    if [[ ! "${__bgen_previous_rc+x}" ]]; then
		        export __bgen_previous_rc=0
		        export __bgen_test_prev_cmd=""
		        export __bgen_test_prev_line_nr=1
		    elif ((__bgen_previous_rc == 0)); then
		        export __bgen_previous_rc="$__bgen_test_current_rc"
		        export __bgen_test_prev_cmd="$__bgen_test_current_cmd"
		        export __bgen_test_prev_line_nr="$__bgen_test_current_line_nr"
		    fi
		
		    if [[ "${__bgen_test_prev_subshell:-}" != "$BASH_SUBSHELL" ]]; then
		        trap 'trap - DEBUG; __bgen_test_exit_handler "$LINENO" 1' EXIT
		        export __bgen_test_prev_subshell=$BASH_SUBSHELL
		        # __bgen_test_covered_lines=()
		
		        # special case for multiline output subshells "$(\n ... )"
		        if [[ "${__bgen_test_prev_cmd}" == *$'\n'* ]]; then
		            # calculate number of lines by removing all \n chars
		            # and getting character difference from the original string
		            : "${__bgen_test_prev_cmd//$'\n'/}"
		            __bgen_test_subshell_line_count=$((${#__bgen_test_prev_cmd} - ${#_} + 1))
		
		            # echo "@" "$__bgen_test_subshell_line_count" "$__bgen_test_prev_line_nr" "$__bgen_test_prev_cmd" >&2
		
		            __bgen_test_subshell_line_start=$((__bgen_test_prev_line_nr - __bgen_test_subshell_line_count + 1))
		            __bgen_test_subshell_line_end=$((__bgen_test_prev_line_nr))
		            # else
		            # echo "-" "$__bgen_test_prev_line_nr" "$__bgen_test_prev_cmd" >&2
		        fi
		    fi
		
		    export __bgen_test_current_rc="$rc"
		    export __bgen_test_current_cmd="$cmd"
		
		    if [[ "${__bgen_test_subshell_line_start+x}" ]] && ((\
		    __bgen_test_subshell_line_start <= line_nr && line_nr >= __bgen_test_subshell_line_end)); then
		        # echo "?" "$line_nr" "$((line_nr - __bgen_test_subshell_line_count + 1))" \
		        #     "$__bgen_test_subshell_line_start" "$cmd" >&2
		        line_nr=$((line_nr - __bgen_test_subshell_line_count + 1))
		        __bgen_test_covered_lines[$line_nr]=2 # run this in the second pass
		    else
		        line_nr="$line_nr"
		        __bgen_test_covered_lines[$line_nr]=1
		    fi
		    export __bgen_test_current_line_nr="$line_nr"
		
		    # printf '%s %4s %4s %s\n' "$BASH_SUBSHELL" "$line_nr" "${BASH_LINENO[0]}" "$cmd" >&2
		    # if [[ "$cmd" =~ $'\n'[[:space:]]*\)[[:space:]]* ]]; then
		    #     echo "@@@@@ got a culprit here" >&2
		    # fi
		
		    # restore the original value of $_
		    : "$old_"
		}
		export -f __bgen_test_debug_handler
		
		# joins lines with a delimited
		__bgen_test_join_by() {
		    if (($# <= 1)); then
		        return 0
		    fi
		
		    local delimiter="$1"
		    local first="$2"
		    shift 2
		
		    printf '%s' "$first" "${@/#/$delimiter}"
		}
		
		# Returns true if a line is covered according to the coverage map
		__bgen_is_line_covered() {
		    local line_nr="$1"
		    local line="$2"
		
		    # printf '%s %s %s %s\n' "$line_nr" $((coverage_map[line_nr])) "$pass_nr" "$line" >&2
		    # if ((coverage_map[line_nr] == pass_nr)); then
		    if ((coverage_map[line_nr])); then
		        # line is in the coverage map
		        return 0
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*$ ]]; then
		        # line is empty space
		        # covered only if the previous line also covered
		        ((${is_prev_line_covered_stack[0]-}))
		        return
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*\# ]]; then
		        # line is a comment
		        # covered only if the previous line also covered
		        ((${is_prev_line_covered_stack[0]-}))
		        return
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*(\(|\{|\)|\}|do|done|then|fi)[[:space:]]*$ ]]; then
		        # line is a single curly brace or parenthesis
		        # covered only if the previous line also covered
		        ((${is_prev_line_covered_stack[0]-}))
		        return
		    fi
		
		    # otherwise, line is not covered
		    return 1
		}
		
		# prints coverage report for a given file
		__bgen_test_add_file_report() {
		    local filename="$1"
		    local covered_hunks="$2"
		    local covered_lines_count="$3"
		    local total_lines_count="$4"
		
		    local percent=$((100 * covered_lines_count / total_lines_count))
		    local filename_short="${filename/$PWD\//}"
		
		    if ((percent >= BGEN_COVERAGE_H_THRESHOLD)); then
		        local coverage_rating="h"
		        local coverage_color="$__BGEN_TEST_COL_SUCCESS"
		    elif ((percent >= BGEN_COVERAGE_M_THRESHOLD)); then
		        local coverage_rating="m"
		        local coverage_color="$__BGEN_TEST_COL_WARNING"
		    else
		        local coverage_rating="l"
		        local coverage_color="$__BGEN_TEST_COL_DANGER"
		    fi
		
		    if [[ "$BGEN_HTML_REPORT_FILE" ]]; then
		        local file_id="${filename_short//[![:alnum:]-_]/_}"
		
		        local code
		        code="$(cat "$filename")"
		        code="${code//</&lt;}"
		        code="${code//>/&gt;}"
		
		        local html
		        html="${__BGEN_COVERAGE_HTML_FILE//__COVERAGE_FILE_NAME__/$filename_short}"
		        html="${html//__COVERAGE_FILE_ID__/$file_id}"
		        html="${html//__COVERAGE_FILE_COVERED__/$covered_lines_count}"
		        html="${html//__COVERAGE_FILE_LINES__/$total_lines_count}"
		        html="${html//__COVERAGE_FILE_PERCENT__/$percent}"
		        html="${html//__COVERAGE_FILE_RATING__/$coverage_rating}"
		        html="${html//__COVERAGE_FILE_HUNKS__/$covered_hunks}"
		        html="${html//__COVERAGE_FILE_CODE__/$code}"
		
		        html_report+="$html"
		    fi
		
		    local report_line
		    report_line="$(
		        printf '%s %b(%s/%s)\t%b%3s%%%b' "$filename_short" \
		            "$__BGEN_TEST_COL_TRIVIAL" "$covered_lines_count" \
		            "$total_lines_count" "$coverage_color" "$percent" "$__BGEN_TEST_COL_RESET"
		    )"
		
		    coverage_report+=("$report_line")
		}
		
		__bgen_test_reverse_lines() {
		    tac 2>/dev/null || tail -r 2>/dev/null || gtac
		}
		
		__bgen_test_count_lines() {
		    if wc -l <<<"$1"; then
		        return
		    fi
		
		    # calculate number of lines by removing all \n chars
		    # and getting character difference from the original string
		    : "${1//$'\n'/}"
		    echo $((${#1} - ${#_} + 1))
		}
		
		# takes trailing lines (ending with backslash) into account
		# in the length of trails map
		__bgen_test_normalize_trails_map() {
		    local current_trail=0
		    local trail_start=0
		
		    local line_nr
		    line_nr=$(__bgen_test_count_lines "$BASH_EXECUTION_STRING")
		    while IFS= read -r line; do
		        if ((trails_map[line_nr])); then
		            current_trail=$((line_nr))
		            trail_start=$((line_nr - trails_map[line_nr]))
		        elif ((trail_start != 0 && line_nr < trail_start)); then
		            current_trail=0
		            trail_start=0
		            # echo -----
		            line_nr=$((line_nr - 1))
		            continue
		        fi
		
		        if ((line_nr <= current_trail && line_nr > trail_start)) \
		            && [[ "$line" =~ [\\]$ ]] && ! [[ "$line" =~ \\[\\]$ ]]; then
		            # shift all lines in this trail by 1
		            trail_start=$((trail_start - 1))
		            for ((i = trail_start + 1; i <= line_nr; i++)); do
		                if [[ "${coverage_map[$((i + 1))]+x}" ]]; then
		                    coverage_map[$i]=$((coverage_map[i + 1]))
		                else
		                    unset "coverage_map[$i]"
		                fi
		                # echo "$i ${coverage_map[$i]-}" >&2
		            done
		            # echo "---" >&2
		            unset "coverage_map[$line_nr]"
		        fi
		
		        #         if ((line_nr <= current_trail && line_nr > trail_start)); then
		        #             echo "${coverage_map[$line_nr]-.} $line_nr $line"
		        #         fi
		
		        line_nr=$((line_nr - 1))
		    done < <(__bgen_test_reverse_lines <<<"$BASH_EXECUTION_STRING")
		}
		
		# print final coverage report
		__bgen_test_make_coverage_report() {
		    shopt -u extglob
		
		    local html_report=""
		    local coverage_report=()
		
		    local files_stack=("UNKNOWN_FILE")
		    local line_nrs_stack=(0)
		    local offsets_stack=(0)
		
		    local covered_lines_stack=(0)
		    local total_lines_stack=(0)
		
		    local total_covered=0
		    local total_lines=0
		
		    local pending_lines=0 # lines that end with a backslash
		    local covered_hunks=()
		    local covered_hunk_count_stack=(0)
		    local hunk_start_stack=("")
		    local hunk_end_stack=("")
		
		    local subshell_stack=(1)
		    local is_prev_line_covered_stack=(1)
		
		    __bgen_test_normalize_trails_map
		
		    local line_nr=0
		    while IFS= read -r line; do
		        line_nr=$((line_nr + 1))
		
		        : "${line%${line##*[![:space:]]}}"    # strip any trailing whitespace if any
		        local line="${_#${_%%[![:space:]]*}}" # strip leading whitepsace if any
		
		        # if ((trails_map[line_nr])); then
		        #     echo "GOT ONE $line_nr $((line_nr - line_nrs_stack[0] - offsets_stack[0])) $line" >&2
		        # fi
		
		        if [[ "$line" =~ ([\\]|\$\()$ ]] && ! [[ "$line" =~ \\([\\]|\$\()$ ]]; then
		            pending_lines=$((pending_lines + 1))
		            # printf '\\ %4s %s %s\n' "$line_nr" "$pending_lines" "$line" >&2
		            continue
		        fi
		
		        if [[ "$line" =~ ^\#[[:space:]]BGEN__BEGIN[[:space:]] ]]; then
		            : "${line#*BGEN__BEGIN[[:space:]]}"
		            local file="${_#${_%%[![:space:]]*}}"
		
		            files_stack=("$file" "${files_stack[@]}")
		            line_nrs_stack=("$line_nr" "${line_nrs_stack[@]}")
		            offsets_stack=(0 "${offsets_stack[@]}")
		
		            covered_lines_stack=(0 "${covered_lines_stack[@]}")
		            total_lines_stack=(0 "${total_lines_stack[@]}")
		
		            covered_hunk_count_stack=(0 "${covered_hunk_count_stack[@]}")
		            hunk_start_stack=("" "${hunk_start_stack[@]}")
		            hunk_end_stack=("" "${hunk_end_stack[@]}")
		
		            subshell_stack=("${subshell_stack[0]}" "${subshell_stack[@]}")
		            is_prev_line_covered_stack=(1 "${is_prev_line_covered_stack[@]}")
		            pending_lines=0
		
		            # printf '@ %4s %s %s\n' "$line_nr" "$pending_lines" "$line" >&2
		            continue
		        fi
		
		        if [[ "$line" =~ ^\#[[:space:]]BGEN__END[[:space:]] ]]; then
		            if [[ "${hunk_start_stack[0]}" ]]; then
		                if [[ "${hunk_start_stack[0]}" == "${hunk_end_stack[0]}" ]]; then
		                    covered_hunks+=("${hunk_start_stack[0]}")
		                else
		                    covered_hunks+=("${hunk_start_stack[0]}-${hunk_end_stack[0]}")
		                fi
		                covered_hunk_count_stack[0]=$((covered_hunk_count_stack[0] + 1))
		                hunk_start_stack[0]=""
		                hunk_end_stack[0]=""
		            fi
		
		            local file_covered_hunks=("${covered_hunks[@]::${covered_hunk_count_stack[0]}}")
		            __bgen_test_add_file_report "${files_stack[0]}" \
		                "$(__bgen_test_join_by "," "${file_covered_hunks[@]}")" \
		                "${covered_lines_stack[0]}" "${total_lines_stack[0]}"
		
		            local file_start="${line_nrs_stack[0]}"
		            local file_size=$((line_nr - file_start))
		
		            files_stack=("${files_stack[@]:1}")
		            line_nrs_stack=("${line_nrs_stack[@]:1}")
		            offsets_stack=("${offsets_stack[@]:1}")
		            offsets_stack[0]=$((offsets_stack[0] + file_size))
		
		            total_covered=$((total_covered + covered_lines_stack[0]))
		            total_lines=$((total_lines + total_lines_stack[0]))
		
		            covered_lines_stack=("${covered_lines_stack[@]:1}")
		            covered_lines_stack[0]=$((covered_lines_stack[0] + 1))
		
		            total_lines_stack=("${total_lines_stack[@]:1}")
		            total_lines_stack[0]=$((total_lines_stack[0] + 1))
		
		            covered_hunks=("${covered_hunks[@]:${covered_hunk_count_stack[0]}}")
		            covered_hunk_count_stack=("${covered_hunk_count_stack[@]:1}")
		            hunk_start_stack=("${hunk_start_stack[@]:1}")
		            hunk_end_stack=("${hunk_end_stack[@]:1}")
		
		            if [[ "${hunk_start_stack[0]}" ]]; then
		                hunk_end_stack[0]=$((hunk_end_stack[0] + 1))
		            else
		                local line_nr_offset=$((line_nr - line_nrs_stack[0] - offsets_stack[0]))
		                hunk_start_stack[0]="$line_nr_offset"
		                hunk_end_stack[0]="$line_nr_offset"
		            fi
		
		            # printf '@ %4s %s %s\n' "$line_nr" "$pending_lines" "$line" >&2
		
		            subshell_stack=("${subshell_stack[@]:1}")
		            is_prev_line_covered_stack=("${is_prev_line_covered_stack[@]:1}")
		            pending_lines=0
		
		            continue
		        fi
		
		        if ((${#files_stack[@]} > 1)); then
		            if __bgen_is_line_covered "$line_nr" "$line"; then
		                if [[ "${hunk_start_stack[0]}" ]]; then
		                    hunk_end_stack[0]=$((hunk_end_stack[0] + pending_lines + 1))
		                else
		                    local line_nr_offset=$((line_nr - line_nrs_stack[0] - offsets_stack[0]))
		                    hunk_start_stack[0]=$((line_nr_offset - pending_lines))
		                    hunk_end_stack[0]="$line_nr_offset"
		                fi
		
		                covered_lines_stack[0]=$((covered_lines_stack[0] + pending_lines + 1))
		
		                is_prev_line_covered_stack[0]=1
		
		                # printf -- '@ %4s %s %s %s/%s/%s\n' "$line_nr" "$pending_lines" "$line" $((line_nr - line_nrs_stack[0] - offsets_stack[0])) $((line_nrs_stack[0])) $((offsets_stack[0])) >&2
		            else
		                if [[ "${hunk_start_stack[0]}" ]]; then
		                    if [[ "${hunk_start_stack[0]}" == "${hunk_end_stack[0]}" ]]; then
		                        covered_hunks+=("${hunk_start_stack[0]}")
		                    else
		                        covered_hunks+=("${hunk_start_stack[0]}-${hunk_end_stack[0]}")
		                    fi
		
		                    covered_hunk_count_stack[0]=$((covered_hunk_count_stack[0] + 1))
		                    hunk_start_stack[0]=""
		                    hunk_end_stack[0]=""
		                fi
		
		                is_prev_line_covered_stack[0]=0
		                # printf -- '- %4s %s %s %s/%s/%s\n' "$line_nr" "$pending_lines" "$line" $((line_nr - line_nrs_stack[0] - offsets_stack[0])) $((line_nrs_stack[0])) $((offsets_stack[0])) >&2
		            fi
		
		            total_lines_stack[0]=$((total_lines_stack[0] + pending_lines + 1))
		            # else
		            # printf -- '. %4s %s %s\n' "$line_nr" "$pending_lines" "$line" >&2
		        fi
		        pending_lines=0
		
		    done <<<"$BASH_EXECUTION_STRING"
		
		    if ((total_lines == 0)); then
		        echo "    Nothing to cover :/"
		        return
		    fi
		
		    local coverage_percent
		    coverage_percent=$((100 * total_covered / total_lines))
		    if ((coverage_percent >= BGEN_COVERAGE_H_THRESHOLD)); then
		        local coverage_color="$__BGEN_TEST_COL_SUCCESS"
		        local coverage_rating="h"
		    elif ((coverage_percent >= BGEN_COVERAGE_M_THRESHOLD)); then
		        local coverage_color="$__BGEN_TEST_COL_WARNING"
		        local coverage_rating="m"
		    else
		        local coverage_color="$__BGEN_TEST_COL_DANGER"
		        local coverage_rating="l"
		    fi
		
		    # print file reports
		    __bgen_test_format_columns < <(
		        printf '  \t%s\n' "${coverage_report[@]}"
		        printf '\n  \tTOTAL COVERED %b(%s/%s)\t%b%3s%%%b\n' \
		            "$__BGEN_TEST_COL_TRIVIAL" "$total_covered" "$total_lines" \
		            "$coverage_color" "$coverage_percent" "$__BGEN_TEST_COL_RESET"
		    )
		
		    # save html report
		    if [[ "$BGEN_HTML_REPORT_FILE" ]]; then
		        local coverage_date
		        coverage_date=$(date)
		
		        local html_header="${__BGEN_COVERAGE_HTML_HEADER//__COVERAGE_DATE__/$coverage_date}"
		        html_header="${html_header//__COVERAGE_TITLE__/Coverage report}"
		        html_header="${html_header//__COVERAGE_TOTAL_COVERED__/$total_covered}"
		        html_header="${html_header//__COVERAGE_TOTAL_LINES__/$total_lines}"
		        html_header="${html_header//__COVERAGE_TOTAL_PERCENT__/$coverage_percent}"
		        html_header="${html_header//__COVERAGE_TOTAL_RATING__/$coverage_rating}"
		
		        local final_html_report="$html_header"
		        final_html_report+="$html_report"
		        final_html_report+="${__BGEN_COVERAGE_HTML_FOOTER}"
		        echo "$final_html_report" >"$BGEN_HTML_REPORT_FILE"
		
		        printf "\n    %bCoverage report file: %s%b\n" \
		            "$__BGEN_TEST_COL_TITLE" "$BGEN_HTML_REPORT_FILE" "$__BGEN_TEST_COL_RESET"
		    fi
		}
		
		# formats tab separated stdin entries as columns
		# shellcheck disable=SC2120
		__bgen_test_format_columns() {
		    local separator="${1:-  }"
		
		    if column -o "$separator" -s $'\t' -t -L 2>/dev/null; then
		        return
		    fi
		
		    # parse manually
		    local column_widths=()
		    local lines=()
		    local cell
		    local cell_width
		
		    # for each column find the longest cell
		    while IFS= read -r line; do
		        if [[ "$line" ]]; then
		            local i=0
		            while IFS= read -r cell; do
		                cell_width="${#cell}"
		                if ((cell_width > column_widths[i])); then
		                    column_widths[$i]="$cell_width"
		                fi
		                i=$((i + 1))
		            done <<<"${line//$'\t'/$'\n'}"
		        fi
		
		        lines+=("$line")
		    done
		
		    # generate a printf string such as it can print each cells at a given width
		    local printf_query
		    printf_query=$(printf -- "$separator%%-%ss" "${column_widths[@]}")
		    for line in "${lines[@]-}"; do
		        if [[ ! "$line" ]]; then
		            echo
		            continue
		        fi
		
		        cells=()
		        while IFS= read -r cell; do
		            cells+=("$cell")
		        done <<<"${line//$'\t'/$'\n'}"
		        # shellcheck disable=SC2059
		        printf "${printf_query/$separator/}\n" "${cells[@]}"
		    done
		}
		
		__bgen_test_run_single() {
		    local test_func="$1"
		    local stdout_file stderr_file env_dir
		
		    stdout_file="$(mktemp)"
		    # shellcheck disable=SC2064
		    trap "rm '$stdout_file'" EXIT
		
		    stderr_file="$(mktemp)"
		    # shellcheck disable=SC2064
		    trap "rm '$stderr_file'" EXIT
		
		    env_dir="$(mktemp -d)"
		    # shellcheck disable=SC2064
		    trap "rm -rf '$env_dir'" EXIT
		    export __bgen_env_dir="$env_dir"
		
		    # we don't want this subshell to cause the entire test to fail
		    # so we relax bash options until we get a status code
		    set +o errexit +o errtrace +o nounset +o pipefail
		    (
		        # Used to track coverage
		        __bgen_test_covered_lines=()
		
		        # enable some bash options to allow error checking
		        set -o errexit -o errtrace -o nounset -o pipefail -o functrace
		
		        # set up some hooks to print original error lines and files
		        trap '__bgen_test_debug_handler "$?" "$LINENO" "$BASH_COMMAND" "$_"' DEBUG
		        trap 'trap - DEBUG; __bgen_test_error_handler "$LINENO"' ERR
		        trap 'trap - DEBUG; __bgen_test_exit_handler "$LINENO"' EXIT
		
		        # call our test function
		        "$test_func"
		
		        # workaround to check if function didn't end prematurely
		        # bash 3.2 exists with rc=0 on unset variables :/
		        __func_finished_successfully=1
		    ) >"$stdout_file" 2>"$stderr_file"
		    local err=$?
		    set -o errexit -o errtrace -o nounset -o pipefail
		
		    # Merge covered lines into the global list
		    for env_file in "$env_dir"/*; do
		        if [[ "$env_file" == "$env_dir/*" ]]; then
		            break
		        fi
		
		        # TODO: Make coverage work for all subshells, for now skip other subshells
		        # if [[ "${env_file##*/}" != 1_* ]]; then
		        #     continue
		        # fi
		
		        local env_arrays
		        env_arrays="$(<"$env_file")"
		        # echo "# $env_file $env_arrays" >&2
		        if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4))); then
		            # workaround bash <4.4 quoting the content of the variables in declare's output
		            local intermediary_coverage_map=()
		            local affect_intermediary_coverage_map="'intermediary_coverage_map+="
		            local intermediary_trails_map=()
		            local affect_intermediary_trails_map="'intermediary_trails_map+="
		            local newline_sub="'"$'\n'"'"
		            local newline=$'\n'
		
		            # also these versions for somereason concat array elements instead of replacing them
		            # so we unset existing values before setting new ones
		            : "${env_arrays//declare -a __bgen_test_covered_lines=\'/$affect_intermediary_coverage_map}"
		            : "${_//declare -a __bgen_test_subshell_trails=\'/$affect_intermediary_trails_map}"
		            : "${_//$newline_sub/$newline}"
		            eval "$(eval "echo $_")"
		            for index in "${!intermediary_coverage_map[@]}"; do
		                unset "coverage_map[$index]"
		            done
		            for index in "${!intermediary_trails_map[@]}"; do
		                unset "trails_map[$index]"
		            done
		
		            local affect_coverage_map="'coverage_map+="
		            local affect_trails_map="'trails_map+="
		            : "${env_arrays//declare -a __bgen_test_covered_lines=\'/$affect_coverage_map}"
		            : "${_//declare -a __bgen_test_subshell_trails=\'/$affect_trails_map}"
		            : "${_//$newline_sub/$newline}"
		            eval "$(eval "echo $_")"
		        else
		            : "${env_arrays//declare -a __bgen_test_covered_lines=/coverage_map+=}"
		            : "${_//declare -a __bgen_test_subshell_trails=/trails_map+=}"
		            eval "$_"
		        fi
		    done
		
		    # print a dot or F depending on test status
		    if ((err)); then
		        printf "%bF%b" "$__BGEN_TEST_COL_DANGER" "$__BGEN_TEST_COL_RESET"
		        failed_tests_funcs+=("$test_func")
		    else
		        passed_test_count=$((passed_test_count + 1))
		        printf "%b.%b" "$__BGEN_TEST_COL_SUCCESS" "$__BGEN_TEST_COL_RESET"
		    fi
		
		    : "${BGEN_NO_CAPTURE:=}"
		    if ! ((err || BGEN_NO_CAPTURE)); then
		        return
		    fi
		
		    if [[ -s "$stdout_file" || -s "$stderr_file" ]]; then
		        local report
		        report=$(
		            printf '\n%b----- %s ----- %b\n' "$__BGEN_TEST_COL_FILENAME" "$test_func" "$__BGEN_TEST_COL_RESET"
		
		            if [[ -s "$stdout_file" ]]; then
		                printf "%bstdout:%b\n" "$__BGEN_TEST_COL_TRIVIAL" "$__BGEN_TEST_COL_RESET"
		                cat "$stdout_file"
		                echo
		            fi
		
		            if [[ -s "$stderr_file" ]]; then
		                printf "%bstderr:%b\n" "$__BGEN_TEST_COL_TRIVIAL" "$__BGEN_TEST_COL_RESET"
		                cat "$stderr_file"
		                echo
		            fi
		        )
		        test_reports+=("$report")
		    fi
		}
		
		if [[ "$NO_COLOR" ]]; then
		    __BGEN_TEST_COL_DANGER=""
		    __BGEN_TEST_COL_WARNING=""
		    __BGEN_TEST_COL_SUCCESS=""
		    __BGEN_TEST_COL_TITLE=""
		    __BGEN_TEST_COL_FILENAME=""
		    __BGEN_TEST_COL_RESET=""
		else
		    __BGEN_TEST_COL_DANGER="\e[31m"
		    __BGEN_TEST_COL_WARNING="\e[33m"
		    __BGEN_TEST_COL_SUCCESS="\e[32m"
		    __BGEN_TEST_COL_TITLE="\e[36m"
		    __BGEN_TEST_COL_FILENAME="\e[33m"
		    __BGEN_TEST_COL_TRIVIAL="\e[90m"
		    __BGEN_TEST_COL_RESET="\e[0m"
		fi
		
		read -rd "" __BGEN_COVERAGE_HTML_HEADER <<-"EOF" || :
		<html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>__COVERAGE_TITLE__</title>
		
		    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-coy.min.css"
		        integrity="sha512-CKzEMG9cS0+lcH4wtn/UnxnmxkaTFrviChikDEk1MAWICCSN59sDWIF0Q5oDgdG9lxVrvbENSV1FtjLiBnMx7Q=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css"
		        integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.css"
		        integrity="sha512-nXlJLUeqPMp1Q3+Bd8Qds8tXeRVQscMscwysJm821C++9w6WtsFbJjPenZ8cQVMXyqSAismveQJc0C1splFDCA=="
		        crossorigin="anonymous" />
		    <style>
		        body {
		            font-family: monospace;
		        }
		        pre[class*=language-]:before, pre[class*=language-]:after {
		            display: none;
		            content: unset;
		        }
		        .coverage-file pre {
		            margin-bottom: 1rem;
		            font-size: 0.7rem;
		        }
		        .line-highlight {
		            background: linear-gradient(to right,hsl(100deg 89% 63% / 12%) 70%,hsl(105deg 86% 63% / 22%));
		        }
		        .coverage-percent {
		            color: white;
		            padding: 0 0.1rem;
		            display: inline-block;
		            text-align: center;
		            min-width: 2.2rem;
		        }
		        .coverage-rating-h .coverage-percent {
		            background-color: green;
		        }
		        .coverage-rating-m .coverage-percent {
		            background-color: orange;
		        }
		        .coverage-rating-l .coverage-percent {
		            background-color: red;
		        }
		    </style>
		</head>
		<body>
		<div class="coverage-header coverage-rating-__COVERAGE_TOTAL_RATING__">
		    <div class="stats">
		        <span class="coverage-percent">__COVERAGE_TOTAL_PERCENT__%</span>
		        Total (__COVERAGE_TOTAL_COVERED__/__COVERAGE_TOTAL_LINES__)
		    </div>
		    <div class="date">
		        Date: __COVERAGE_DATE__
		        <a href="#" class="collapse-all">Collapse All</a>
		        <a href="#" class="expand-all">Expand All</a>
		    </div>
		    <hr/>
		</div>
		EOF
		
		read -rd "" __BGEN_COVERAGE_HTML_FILE <<-"EOF" || :
		<details class="coverage-file coverage-rating-__COVERAGE_FILE_RATING__" id="__COVERAGE_FILE_ID__" open>
		    <summary class="coverage-file-title">
		        <span class="coverage-percent">__COVERAGE_FILE_PERCENT__%</span>
		        <span class="coverage-file-name">__COVERAGE_FILE_NAME__</span>
		        <span class="coverage-covered-lines">(<span
		                class="covered"
		            >__COVERAGE_FILE_COVERED__</span>/<span
		                class="total"
		            >__COVERAGE_FILE_LINES__</span>)<span>
		    </summary>
		    <pre
		        class="line-numbers" id="pre-__COVERAGE_FILE_ID__" data-line="__COVERAGE_FILE_HUNKS__"
		    ><code class="language-bash">__COVERAGE_FILE_CODE__</code></pre>
		</details>
		EOF
		
		read -rd "" __BGEN_COVERAGE_HTML_FOOTER <<-"EOF" || :
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"
		    integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js"
		    integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js"
		    integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.js"
		    integrity="sha512-MGMi0fbhnsk/a/9vCluWv3P4IOfHijjupSoVYEdke+QQyGBOAaXNXnwW6/IZSH7JLdknDf6FL6b57o+vnMg3Iw=="
		    crossorigin="anonymous"></script>
		<script>
		(function() {
		    function collapseAll() {
		        var elems = document.querySelectorAll('details[open]');
		        for (var i = 0; i < elems.length; ++i) {
		            elems[i].open = false;
		        }
		    }
		    function expandAll() {
		        var elems = document.querySelectorAll('details');
		        for (var i = 0; i < elems.length; ++i) {
		            elems[i].open = true;
		        }
		    }
		
		    var collapseBtn = document.querySelector('.collapse-all');
		    if (collapseBtn) {
		        collapseBtn.addEventListener('click', function(e) {
		            e.preventDefault();
		            collapseAll();
		        })
		    }
		
		    var expandBtn = document.querySelector('.expand-all');
		    if (expandBtn) {
		        expandBtn.addEventListener('click', function(e) {
		            e.preventDefault();
		            expandAll();
		        })
		    }
		
		    // collapsing using js because line highlighter doesn't work on collapsed details blocks
		    setTimeout(collapseAll);
		})();
		</script>
		</body>
		</html>
		EOF
		
		__bgen_test_entrypoint "$@"
		BGEN_EOF_1664727455
# BGEN__INCLUDE_STR_END
    process_input <<<"$testlib"
}

# shellcheck disable=SC2034
read_project_meta() {
    is_declared import_paths || local import_paths

    # make sure some vars are local if not declared on a parent scope
    is_declared project_root || local project_root
    is_declared project_name || local project_name
    is_declared header_file || local header_file
    is_declared entrypoint_file || local entrypoint_file
    is_declared entrypoint_func || local entrypoint_func
    is_declared shebang_string || local shebang_string
    is_declared output_file || local output_file
    is_declared tests_dir || local tests_dir

    # set some defaults
    entrypoint_file="src/main.sh"
    shebang_string="#!/usr/bin/env bash"
    tests_dir="tests"

    local import_paths_extra=()
    import_paths=()
    if [[ "${BGEN_IMPORT_PATHS:-}" ]]; then
        while read -r -d ':' path; do
            import_paths+=("$path")
        done <<<"${BGEN_IMPORT_PATHS}:"
    fi
    import_paths+=(deps/*/lib)

    # source config file
    project_root="$PWD"
    while true; do
        # shellcheck disable=SC1091
        if [[ -f ".bgenrc" ]]; then
            project_root="$PWD"
            source ".bgenrc"
            break
        elif [[ -f "bgenrc.sh" ]]; then
            project_root="$PWD"
            source "bgenrc.sh"
            break
        fi

        if [[ "$PWD" == "/" ]]; then
            break
        fi

        cd ..
    done

    # set default project name
    if [[ ! "${project_name:-}" ]]; then
        # ${file##*/} keeps only what's after the last slash (aka the basename)
        project_name="${PWD##*/}"
    fi

    # set default output file
    if [[ ! "${output_file:-}" ]]; then
        output_file="bin/$project_name"
    fi

    # set default entrypoint function
    if [[ ! "${entrypoint_func:-}" ]]; then
        entrypoint_func="$project_name"
    fi

    # add the extra import paths
    if ((${#import_paths_extra[@]})); then
        import_paths=("${import_paths_extra[@]}" "${import_paths[@]}")
    fi
}

echo_header() {
    if [[ -f "$header_file" ]]; then
        printf '%s\n\n' "$shebang_string"

        process_file "$header_file"
    else
        local default_header
# BGEN__INCLUDE_STR_BEGIN
        read -r -d '' default_header <<-"BGEN_EOF_176268532" || :
			#!/usr/bin/env bash
			
			# Exit on error. Append "|| true" if you expect an error.
			set -o errexit
			# Exit on error inside any functions or subshells.
			set -o errtrace
			# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
			set -o nounset
			# Catch the error in case mysqldump fails (but gzip succeeds) in $(mysqldump | gzip)
			set -o pipefail
			# Turn on traces, useful for debugging. Set _XTRACE to enable
			[[ "${_XTRACE:-}" ]] && set -o xtrace
			
			# check whether script is source or directly executed
			if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
			    __process__="$__BGEN_PIPE_SOURCE__"
			elif [[ "${BASH_SOURCE+x}" ]]; then
			    __process__="${BASH_SOURCE[0]}"
			else
			    __process__="$0"
			fi
			
			if [[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]]; then
			    __main__= # false
			    # shellcheck disable=SC2154
			    if [[ "${__usage__+x}" ]]; then
			        if [[ "${BASH_SOURCE[1]}" = "${0}" ]]; then
			            __main__=1 # true
			        fi
			
			        __process__="${BASH_SOURCE[1]}"
			    fi
			else
			    # shellcheck disable=SC2034
			    __main__=1 # true
			    [[ "${__usage__+x}" ]] && unset -v __usage__
			fi
			
			# Set magic variables for current file, directory, os, etc.
			__dir__="$(cd "$(dirname "${__process__}")" && pwd)"
			__file__="${__dir__}/$(basename "${__process__}")"
			# shellcheck disable=SC2034,SC2015
			__base__="$(basename "${__file__}" .sh)"
			# shellcheck disable=SC2034,SC2015
			if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
			    __invocation__="${__BGEN_PIPE_SOURCE__}"
			else
			    __invocation__="$(printf %q "${__file__}")"
			fi
			
			# Define the environment variables (and their defaults) that this script depends on
			LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
			NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected
			BGEN_EOF_176268532
# BGEN__INCLUDE_STR_END

        echo "$default_header"
    fi

    # Add some spacing
    printf '\n\n'
}

process_file() {
    local file="$1"
    file=$(find_file "$file")

    # get directory name
    : "${file%/*}"
    local src_dir="${_:-/}"

    pushd "$src_dir" >/dev/null || return
    process_input <"$file"
    popd >/dev/null || return
}

process_input() {
    local found_first_line=
    while IFS= read -r line; do
        # Process source directives that point ot static files
        process_directive "$line" || { check && continue; }

        # Remove first shebang in the file
        if ! [[ "$found_first_line" ]]; then
            process_shebang "$line" || { check && continue; }
        fi

        if [[ ! "$found_first_line" ]]; then
            if ! echo "$line" | grep -E "^[[:space:]]*$" >/dev/null; then
                found_first_line=1
            fi
        fi

        # Otherwise echo the line as is
        echo "$line"
    done
}

echo_entrypoint_call() {
    if [[ "$entrypoint_func" ]]; then
        # shellcheck disable=SC2016
        printf '\n[[ "$__main__" ]] && %s "$@"\n' "$entrypoint_func"
    fi
}

check() {
    local ret="$?"

    if [[ "$ret" == 200 ]]; then
        return 0
    fi

    if [[ "$ret" ]] && ((ret != 0 && ret != 200)); then
        exit "$ret"
    fi

    return 1
}

process_shebang() {
    local line="$1"
    line=$(trim_str "$line")

    if [[ "$line" =~ ^\#\! ]]; then
        found_first_line=1
        echo "# BGEN__SHEBANG_REMOVED"
        return 200
    fi
}

process_directive() {
    local line="$1"

    if ! [[ "$line" =~ ^[[:space:]]*bgen\: ]]; then
        return 0
    fi

    : "${line%%[![:space:]]*}"
    local indent_size=${#_}

    # escape `` and $()
    : "${line//\`/\\\`}"
    : "${_//\$/\\\$}"
    : "${_//\(/\\\(}"
    : "${_//\)/\\/)}"

    # parse arguments
    declare -a "args=( $_ )"
    if (("${#args[@]}" == 0)); then
        return 0
    fi

    local directive="${args[0]}"
    args=("${args[@]:1}")

    case "$directive" in
    "bgen:import") bgen_import "${args[@]}" ;;
    "bgen:include") bgen_include "${args[@]}" ;;
    "bgen:include_str") bgen_include_str "${args[@]}" ;;
    "bgen:"*) bail "unknown bgen directive: $directive" ;;
    *) ;;
    esac
}

find_file() {
    local file="$1"

    # check if the file exists
    if [[ -r "$file" ]]; then
        realpath "$file"
        return
    fi

    # check in import directories
    for unexpanded_dir in "${import_paths[@]}"; do
        for dir in $unexpanded_dir; do
            # make sure external files are always imported relative to project dir
            if [[ "$dir" != /* ]]; then
                dir="${project_root:-$PWD}/$dir"
            fi

            if [[ -r "$dir/$file" ]]; then
                realpath "$dir/$file"
                return
            fi
        done
    done

    # nothing found :(
    echo "file does not exist or is not readable: $file" >&2
    return 1
}

find_source_file() {
    local file="$1"

    find_file "${file}.sh" 2>/dev/null || find_file "$file"
}

bgen_import() {
    local file
    file=$(find_source_file "$1")

    # Don't re-import file if it was already imported
    if is_in_array "$file" "${imported_files[@]-}"; then
        echo "# BGEN__ALREADY_IMPORTED $file"
    else
        # Mark file as imported
        imported_files+=("$file")

        # Add a comment indicating where the processing starts
        echo "# BGEN__BEGIN $file"

        # Do normal file processing
        process_file "$file"

        # Add a comment indicating where the processing starts
        echo "# BGEN__END $file"
    fi

    # Return 200 to tell check() that we've processed something
    return 200
}

bgen_include() {
    local file
    file=$(find_source_file "$1")

    # Add a comment indicating where the processing starts
    echo "# BGEN__BEGIN $file"

    # Do normal file processing
    process_file "$file"

    # Add a comment indicating where the processing starts
    echo "# BGEN__END $file"

    return 200
}

bgen_include_str() {
    local variable="$1"
    local file="$2"
    file=$(find_file "$file")

    local TAB_SIZE=4
    local indent_size="${indent_size:-0}"
    local tabs=$((indent_size / TAB_SIZE))
    local indent
    indent=$(printf "%${indent_size}s")
    indent_plus=$(printf '\t%.0s' $(seq $((tabs + 1))))

    local heredoc_id="$RANDOM$RANDOM"
    echo "# BGEN__INCLUDE_STR_BEGIN"
    echo "${indent}read -r -d '' ${variable} <<-\"BGEN_EOF_${heredoc_id}\" || :"
    while IFS= read -r line; do
        echo "$indent_plus$line"
    done <"$file"
    echo "${indent_plus}BGEN_EOF_${heredoc_id}"
    echo "# BGEN__INCLUDE_STR_END"

    # Return 200 to tell check() that we've processed something
    return 200
}

is_in_array() {
    local target="$1"
    shift

    for item in "$@"; do
        [[ "$target" == "$item" ]] && return 0
    done

    return 1
}

# Utility function to check if any of the passed variables is not declared
# @param    variable_name...    names of variables to check
is_declared() {
    declare -p "$@" >/dev/null 2>/dev/null
}
# BGEN__END /home/sdrm/projects/bgen/src/build.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/run.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/bgen/src/build.sh

run_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} run"
    bash -c "$(build_project_to_stdout)" "${__base__:-$0} run" "$@"
}

debug_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} debug"
    bash -x -c "$(build_project_to_stdout)" "${__base__:-$0} run" "$@"
}
# BGEN__END /home/sdrm/projects/bgen/src/run.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/test.sh
# BGEN__SHEBANG_REMOVED

# BGEN__ALREADY_IMPORTED /home/sdrm/projects/bgen/src/build.sh

run_project_tests_debug() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} test"
    build_tests_to_stdout "$@"
}

run_project_tests() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} test"
    bash -c "$(build_tests_to_stdout "$@")" "${__base__:-$0} test" "$@"
}
# BGEN__END /home/sdrm/projects/bgen/src/test.sh

# entrypoint
bgen() {
    local cmd="${1:-}"

    if [[ "$cmd" == "build" ]]; then
        build_project
        return
    fi

    if [[ "$cmd" == "run" ]]; then
        shift
        run_project "$@"
        return
    fi

    if [[ "$cmd" == "debug" ]]; then
        shift
        debug_project "$@"
        return
    fi

    if [[ "$cmd" == "test" ]]; then
        shift
        run_project_tests "$@"
        return
    fi

    if [[ "$cmd" == "test-debug" ]]; then
        shift
        run_project_tests_debug "$@"
        return
    fi

    build_project_to_stdout
}

[[ "$__main__" ]] && bgen "$@"
