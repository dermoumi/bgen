#!/usr/bin/env bash

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in case mysqldump fails (but gzip succeeds) in $(mysqldump | gzip)
set -o pipefail
# Turn on traces, useful for debugging. Set _XTRACE to enable
[[ "${_XTRACE:-}" ]] && set -o xtrace

# check whether script is source or directly executed
if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
    __process__="$__BGEN_PIPE_SOURCE__"
elif [[ "${BASH_SOURCE+x}" ]]; then
    __process__="${BASH_SOURCE[0]}"
else
    __process__="$0"
fi

if [[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]]; then
    __main__= # false
    # shellcheck disable=SC2154
    if [[ "${__usage__+x}" ]]; then
        if [[ "${BASH_SOURCE[1]}" = "${0}" ]]; then
            __main__=1 # true
        fi

        __process__="${BASH_SOURCE[1]}"
    fi
else
    # shellcheck disable=SC2034
    __main__=1 # true
    [[ "${__usage__+x}" ]] && unset -v __usage__
fi

# Set magic variables for current file, directory, os, etc.
__dir__="$(cd "$(dirname "${__process__}")" && pwd)"
__file__="${__dir__}/$(basename "${__process__}")"
# shellcheck disable=SC2034,SC2015
__base__="$(basename "${__file__}" .sh)"
# shellcheck disable=SC2034,SC2015
if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
    __invocation__="${__BGEN_PIPE_SOURCE__}"
else
    __invocation__="$(printf %q "${__file__}")"
fi

# Define the environment variables (and their defaults) that this script depends on
LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected


# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/bgen/src/build.sh
# BGEN__SHEBANG_REMOVED

# BGEN__BEGIN /home/sdrm/projects/bgen/src/utils.sh
# BGEN__SHEBANG_REMOVED

bail() {
    local err_message="$1"
    local err_code="${2:-1}"

    echo "$err_message" >&2
    exit "$err_code"
}

trim_str() {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}
# BGEN__END /home/sdrm/projects/bgen/src/utils.sh

build_project() {
    # save it in a temp file first
    local tmp_file
    tmp_file=$(mktemp /tmp/bgen.XXXXXXXXXX)
    # shellcheck disable=SC2064
    trap "rm '$tmp_file' >/dev/null || true" exit

    # build the project
    build_project_to_stdout >"$tmp_file"

    # shellcheck disable=SC1007
    local output_file=""
    read_project_meta

    # make sure the output's directory exists
    local output_dir
    output_dir=$(dirname "$output_file")
    if [[ "$output_dir" && "$output_dir" != "." ]]; then
        mkdir -p "$output_dir"
    fi

    # copy it to the real output dir and make it executable
    cp "$tmp_file" "$output_file"
    chmod +x "$output_file"
}

build_project_to_stdout() {
    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    local imported_files=()

    local project_name="" header_file="" entrypoint_file="" entrypoint_func="" shebang_string="" imports_dir=""
    read_project_meta

    # build the project
    echo_header
    process_file "$entrypoint_file"
    echo_entrypoint_call
}

build_tests_to_stdout() {
    # used later to keep track of whether a file was imported or not
    # declared here to be on the biggest private scope it's needed in
    local imported_files=()

    local project_name="" header_file="" tests_dir="" shebang_string="" imports_dir=""
    read_project_meta

    # make sure tests directory exists
    if ! [[ -d "$tests_dir" ]]; then
        echo "tests directory '$tests_dir' does not exist" >&2
        exit 1
    fi

    local test_files=()
    local test_funcs=()
    local failed=0
    local no_capture="${BGEN_NO_CAPTURE:-0}"
    while (($#)); do
        case "$1" in
        -k)
            test_funcs+=("$2")
            shift 2
            ;;
        -k=*)
            test_funcs+=("${1/-k=/}")
            shift
            ;;
        -C | --no-capture)
            no_capture=1
            shift
            ;;
        *)
            local file="$1"
            shift

            if [[ -f "$file" ]]; then
                test_files+=("$file")
                continue
            fi

            echo "test file '$file' does not exist" >&2
            failed=1
            ;;
        esac
    done

    if ((failed)); then
        exit 1
    elif ! ((${#test_files[@]})); then
        for file in "$tests_dir"/*; do
            if [[ "$(basename "$file")" != "_"* ]]; then
                test_files+=("$file")
            fi
        done
    fi

    # build the tests file
    echo_header
    for test_file in "${test_files[@]}"; do
        [[ -f "$test_file" ]] || continue

        bgen_import "$test_file" || { check && true; }
    done

    echo "__BGEN_TEST_FUNCS__=("
    if ((${#test_funcs[@]})); then
        printf '    %q\n' "${test_funcs[@]}"
    else
        # shellcheck disable=SC2028
        echo "\$(declare -F | awk '\$3 ~ /^ *test_/ {printf \"%s\n\", \$3}')"
    fi
    echo ")"

    echo "BGEN_NO_CAPTURE=$no_capture"

# BGEN__INCLUDE_STR_BEGIN
    testlib=$(
    cat <<-"BGEN_EOF_968302630"
		#!/usr/bin/env bash
		
		__test_failed=()
		__test_report=()
		__bgen_covered_lines=()
		
		if [[ "$NO_COLOR" ]]; then
		    __COL_DANGER=""
		    __COL_SUCCESS=""
		    __COL_TITLE=""
		    __COL_FILENAME=""
		    __COL_RESET=""
		else
		    __COL_DANGER="\e[31m"
		    __COL_SUCCESS="\e[32m"
		    __COL_TITLE="\e[36m"
		    __COL_FILENAME="\e[33m"
		    __COL_RESET="\e[0m"
		fi
		
		__BGEN_COVERAGE_HTML_HEADER=$(
		    cat <<-"EOF"
		<html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>__COVERAGE_TITLE__</title>
		
		    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-coy.min.css"
		        integrity="sha512-CKzEMG9cS0+lcH4wtn/UnxnmxkaTFrviChikDEk1MAWICCSN59sDWIF0Q5oDgdG9lxVrvbENSV1FtjLiBnMx7Q=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css"
		        integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ=="
		        crossorigin="anonymous" />
		    <link rel="stylesheet"
		        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.css"
		        integrity="sha512-nXlJLUeqPMp1Q3+Bd8Qds8tXeRVQscMscwysJm821C++9w6WtsFbJjPenZ8cQVMXyqSAismveQJc0C1splFDCA=="
		        crossorigin="anonymous" />
		    <style>
		        body {
		            font-family: monospace;
		        }
		        .coverage-file {
		            margin-bottom: 2rem;
		        }
		        .coverage-file-name:after {
		            content: ':';
		        }
		        .line-highlight {
		            background: linear-gradient(to right,hsl(100deg 89% 63% / 12%) 70%,hsl(105deg 86% 63% / 22%));
		        }
		    </style>
		</head>
		<body>
		EOF
		)
		
		__BGEN_COVERAGE_HTML_FILE=$(
		    cat <<-"EOF"
		<div class="coverage-file">
		    <p class="coverage-file-name">__COVERAGE_FILE_NAME__</p>
		    <pre
		        class="line-numbers linkable-line-numbers" data-line="__COVERAGE_FILE_LINES__"
		    ><code class="language-bash">__COVERAGE_FILE_CODE__</code></pre>
		</div>
		EOF
		)
		
		__BGEN_COVERAGE_HTML_FOOTER=$(
		    cat <<-"EOF"
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"
		    integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js"
		    integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js"
		    integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow=="
		    crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-highlight/prism-line-highlight.min.js"
		    integrity="sha512-MGMi0fbhnsk/a/9vCluWv3P4IOfHijjupSoVYEdke+QQyGBOAaXNXnwW6/IZSH7JLdknDf6FL6b57o+vnMg3Iw=="
		    crossorigin="anonymous"></script>
		</body>
		</html>
		EOF
		)
		
		# shellcheck disable=SC2120
		__get_source_line() {
		    local bgen_line="$1"
		
		    local line_file=("UNKNOWN_FILE")
		    local line_nr=(0)
		    local line_offset=(0)
		    while IFS= read -r line; do
		        local current_line_nr current_line_type
		        current_line_nr="$(awk '{printf $1}' <<<"$line")"
		        current_line_type="$(awk '{printf $2}' <<<"$line")"
		
		        if ((current_line_nr > bgen_line)); then
		            break
		        fi
		
		        # keep it as ifs, bash 3.2 seems to complain when i use a case here
		        if [[ "$current_line_type" == "BGEN__BEGIN" ]]; then
		            local file
		            file="$(awk '{OFS=""; $1=""; $2=""; printf $0 }' <<<"$line")"
		            line_file=("$file" "${line_file[@]}")
		            line_nr=("$current_line_nr" "${line_nr[@]}")
		            line_offset=(0 "${line_offset[@]}")
		        elif [[ "$current_line_type" == "BGEN__END" ]]; then
		            local file_start_line_nr="${line_nr[0]}"
		            local file_lines=$((current_line_nr - file_start_line_nr))
		            line_file=("${line_file[@]:1}")
		            line_nr=("${line_nr[@]:1}")
		            line_offset=("${line_offset[@]:1}")
		            line_offset[0]=$((line_offset[0] + file_lines))
		        fi
		    done <<<"$__BGEN_LINEMAP__"
		
		    echo "${line_file[0]/$PWD\//}:$((bgen_line - line_nr[0] - line_offset[0]))"
		}
		export -f __get_source_line
		
		__handle_error() {
		    local rc="$__bgen_current_rc"
		
		    if ((BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4)) && [[ "${__bgen_assert_line:-}" ]]; then
		        local line=$((__bgen_assert_line + 1))
		    elif [[ "$__bgen_current_cmd" == "$__bgen_previous_cmd" ]]; then
		        # if we have two successive return commands, use the previous one's line
		        local line="$__bgen_previous_cmd_line"
		    else
		        local line="$__bgen_current_cmd_line"
		
		        if ((BASH_VERSINFO[0] < 4)); then
		            line=$((line + 1))
		        fi
		    fi
		
		    __error_handled=1
		
		    local source_line
		    source_line="$(__get_source_line "$line")"
		    printf '%b%s (rc=%s)%b\n' "$__COL_DANGER" "$source_line" "$rc" "$__COL_RESET" >&2
		
		    exit "$rc"
		}
		export -f __handle_error
		
		__handle_exit() {
		    local rc="$__bgen_current_rc"
		
		    # save coverage file
		    declare -p __bgen_test_covered_lines >"$__bgen_env_file"
		
		    if [[ "${__error_handled:-}" ]]; then
		        exit "$rc"
		    fi
		
		    local line="$__bgen_previous_cmd_line"
		
		    # workaround for bash <4.0 returning 0 on nounset errors
		    if [[ "$rc" == 0 ]]; then
		        [[ "${__func_finished_successfully:-}" ]] && exit 0
		
		        # this is the same code bash returns on version 4+ in these cases
		        rc=127
		
		        if [[ "${__bgen_previous_cmd_line:-}" ]]; then
		            line=$((__bgen_previous_cmd_line))
		        fi
		    elif [[ "${__bgen_previous_cmd_line:-}" ]]; then
		        line="$__bgen_previous_cmd_line"
		    fi
		
		    local source_line
		    source_line="$(__get_source_line "$line")"
		    printf '%b%s (rc=%s)%b\n' "$__COL_DANGER" "$source_line" "$rc" "$__COL_RESET" >&2
		
		    exit "$rc"
		}
		export -f __handle_exit
		
		__handle_debug() {
		    local rc="$1"
		    local line="$2"
		    local cmd="$3"
		
		    if ((BASH_VERSINFO[0] < 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] < 1))); then
		        line=$((line + 1))
		    fi
		
		    if ((__bgen_previous_rc == 0)); then
		        __bgen_previous_rc="$__bgen_current_rc"
		        __bgen_previous_cmd="$__bgen_current_cmd"
		        __bgen_previous_cmd_line="$__bgen_current_cmd_line"
		    fi
		
		    __bgen_current_rc="$rc"
		    __bgen_current_cmd="$cmd"
		    __bgen_current_cmd_line="$line"
		
		    __bgen_test_covered_lines[$line]=1
		}
		export -f __handle_debug
		
		__bgen_join_by() {
		    if (($# <= 1)); then
		        return 0
		    fi
		
		    local delimiter="$1"
		    local first="$2"
		    shift 2
		
		    printf %s "$first" "${@/#/$delimiter}"
		}
		
		__bgen_is_line_covered() {
		    local nr="$1"
		    local line="$2"
		
		    if [[ "${__bgen_covered_lines[$nr]-}" ]]; then
		        return 0
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*[\(\)\{\}]?[[:space:]]*$ ]]; then
		        ((last_line_is_covered))
		        return
		    fi
		
		    if [[ "$line" =~ ^[[:space:]]*\# ]]; then
		        return 0
		    fi
		
		    return 1
		}
		
		__bgen_add_file_coverage() {
		    local filename="$1"
		    local covered_lines="$2"
		
		    local code
		    code="$(cat "$filename")"
		    code="${code//</&lt;}"
		    code="${code//>/&gt;}"
		
		    local html
		    html="${__BGEN_COVERAGE_HTML_FILE/__COVERAGE_FILE_NAME__/${filename/$PWD\//}}"
		    html="${html/__COVERAGE_FILE_LINES__/$covered_lines}"
		    html="${html/__COVERAGE_FILE_CODE__/$code}"
		
		    coverage_output+="$html"
		}
		
		__bgen_report_coverage() {
		    shopt -s extglob
		
		    local coverage_output="${__BGEN_COVERAGE_HTML_HEADER}"
		
		    local line_file=("UNKNOWN_FILE")
		    local line_nr=(0)
		    local line_offset=(0)
		
		    local covered_hunks=()
		    local covered_hunks_count=(0)
		    local hunk_start=("")
		    local hunk_end=("")
		
		    local last_line_is_covered=0
		
		    echo
		    local current_line_nr=0
		    while IFS= read -r line; do
		        current_line_nr=$((current_line_nr + 1))
		
		        if [[ "$line" =~ ^[[:space:]]*\#[[:space:]]BGEN__BEGIN[[:space:]] ]]; then
		            local file="${line/*([[:space:]])\#[[:space:]]BGEN__BEGIN+([[:space:]])/}"
		            line_file=("$file" "${line_file[@]}")
		            line_nr=("$current_line_nr" "${line_nr[@]}")
		            line_offset=(0 "${line_offset[@]}")
		
		            covered_hunks_count=(0 "${covered_hunks_count[@]}")
		            hunk_start=("" "${hunk_start[@]}")
		            hunk_end=("" "${hunk_end[@]}")
		
		            continue
		        elif [[ "$line" =~ ^[[:space:]]*\#[[:space:]]BGEN__END[[:space:]] ]]; then
		            if [[ "${hunk_start[0]}" ]]; then
		                if [[ "${hunk_start[0]}" == "${hunk_end[0]}" ]]; then
		                    covered_hunks+=("${hunk_start[0]}")
		                else
		                    covered_hunks+=("${hunk_start[0]}-${hunk_end[0]}")
		                fi
		                covered_hunks_count[0]=$((covered_hunks_count[0] + 1))
		                hunk_start[0]=""
		                hunk_end[0]=""
		            fi
		
		            local file_covered_hunks=("${covered_hunks[@]::${covered_hunks_count[0]}}")
		            __bgen_add_file_coverage "${line_file[0]}" "$(__bgen_join_by "," "${file_covered_hunks[@]}")"
		
		            local file_start="${line_nr[0]}"
		            local file_size=$((current_line_nr - file_start))
		
		            line_file=("${line_file[@]:1}")
		            line_nr=("${line_nr[@]:1}")
		            line_offset=("${line_offset[@]:1}")
		            line_offset[0]=$((line_offset[0] + file_size))
		
		            covered_hunks=("${covered_hunks[@]:${covered_hunks_count[0]}}")
		            covered_hunks_count=("${covered_hunks_count[@]:1}")
		            hunk_start=("${hunk_start[@]:1}")
		            hunk_end=("${hunk_end[@]:1}")
		
		            if [[ "${hunk_start[0]}" ]]; then
		                hunk_end[0]=$((hunk_end[0] + 1))
		            else
		                local line_nr_offset=$((current_line_nr - line_nr[0] - line_offset[0]))
		                hunk_start[0]="$line_nr_offset"
		                hunk_end[0]="$line_nr_offset"
		            fi
		
		            last_line_is_covered=1
		            continue
		        fi
		
		        # echo "${#line_file[@]}"
		        if ((${#line_file[@]} > 1)); then
		            if __bgen_is_line_covered "$current_line_nr" "$line"; then
		                if [[ "${hunk_start[0]}" ]]; then
		                    hunk_end[0]=$((hunk_end[0] + 1))
		                else
		                    local line_nr_offset=$((current_line_nr - line_nr[0] - line_offset[0]))
		                    hunk_start[0]="$line_nr_offset"
		                    hunk_end[0]="$line_nr_offset"
		                fi
		
		                last_line_is_covered=1
		            else
		                if [[ "${hunk_start[0]}" ]]; then
		                    if [[ "${hunk_start[0]}" == "${hunk_end[0]}" ]]; then
		                        covered_hunks+=("${hunk_start[0]}")
		                    else
		                        covered_hunks+=("${hunk_start[0]}-${hunk_end[0]}")
		                    fi
		
		                    covered_hunks_count[0]=$((covered_hunks_count[0] + 1))
		                    hunk_start[0]=""
		                    hunk_end[0]=""
		                fi
		
		                last_line_is_covered=0
		            fi
		
		            # printf '%s %s:\t%s\e[30m (%s)\e[0m\n' \
		            #     "${last_line_is_covered/0/-}" "$current_line_nr" "$line" "${hunk_start[0]-}-${hunk_end[0]-}" >&2
		        fi
		    done <<<"$BASH_EXECUTION_STRING"
		
		    coverage_output+="${__BGEN_COVERAGE_HTML_FOOTER}"
		    echo "$coverage_output" >"coverage.html"
		
		    echo
		    echo "totol lines $current_line_nr"
		}
		
		assert_status() {
		    local status_code="$?"
		
		    local expected_code="${1:-}"
		    [[ "${2:-}" ]] && status_code="$2"
		
		    [[ "$status_code" == "$expected_code" ]] && return 0
		
		    echo "assert_status: expected $expected_code, got $status_code" >&2
		    __bgen_assert_line="${BASH_LINENO[0]-}"
		    return 1
		}
		export -f assert_status
		
		assert_eq() {
		    local left="$1"
		    local right="$2"
		
		    [[ "$left" == "$right" ]] && return 0
		
		    (
		        echo "assert_eq expected:"
		        echo "$left"
		        echo
		        echo "assert_eq got:"
		        echo "$right"
		    ) >&2
		    __bgen_assert_line="${BASH_LINENO[0]-}"
		    return 1
		}
		export -f assert_eq
		
		__run_test() {
		    local test_func="$1"
		    local stdout_file stderr_file
		
		    stdout_file="$(mktemp)"
		    # shellcheck disable=SC2064
		    trap "rm '$stdout_file'" EXIT
		
		    stderr_file="$(mktemp)"
		    # shellcheck disable=SC2064
		    trap "rm '$stderr_file'" EXIT
		
		    env_file="$(mktemp)"
		    # shellcheck disable=SC2064
		    trap "rm '$env_file'" EXIT
		    export __bgen_env_file="$env_file"
		
		    # we don't want this subshell to cause the entire test to fail
		    # so we relax bash options until we get a status code
		    set +o errexit +o errtrace +o nounset +o pipefail
		    (
		        # Used to track coverage
		        __bgen_test_covered_lines=()
		
		        # set up some hooks to print original error lines and files
		        trap '__handle_debug "$?" "$LINENO" "$BASH_COMMAND"' DEBUG
		        trap 'trap - DEBUG; __handle_error "$LINENO"' ERR
		        trap 'trap - DEBUG; __handle_exit "$LINENO"' EXIT
		
		        # enable some bash options to allow error checking
		        set -o errexit -o errtrace -o nounset -o pipefail -o functrace
		
		        # call our test function
		        "$test_func"
		
		        # workaround to check if function didn't end prematurely
		        # bash 3.2 exists with rc=0 on unset variables :/
		        __func_finished_successfully=1
		    ) >"$stdout_file" 2>"$stderr_file"
		    local err=$?
		    set -o errexit -o errtrace -o nounset -o pipefail
		
		    # Merge covered lines into the global list
		    local coverage_array
		    coverage_array="$(cat "$env_file")"
		    eval "${coverage_array/declare -a __bgen_test_covered_lines=/__bgen_covered_lines+=}"
		
		    # print a dot or F depending on test status
		    if ((err)); then
		        printf "%bF%b" "$__COL_DANGER" "$__COL_RESET"
		        __test_failed+=("$test_func")
		    else
		        printf "%b.%b" "$__COL_SUCCESS" "$__COL_RESET"
		    fi
		
		    : "${BGEN_NO_CAPTURE:=}"
		    if ! ((err || BGEN_NO_CAPTURE)); then
		        return
		    fi
		
		    if [[ -s "$stdout_file" || -s "$stderr_file" ]]; then
		        local report
		        report=$(
		            printf '\n%b----- %s ----- %b\n' "$__COL_FILENAME" "$test_func" "$__COL_RESET"
		
		            if [[ -s "$stdout_file" ]]; then
		                printf "%bstdout:%b\n" "$__COL_TITLE" "$__COL_RESET"
		                cat "$stdout_file"
		                echo
		            fi
		
		            if [[ -s "$stderr_file" ]]; then
		                printf "%bstderr:%b\n" "$__COL_TITLE" "$__COL_RESET"
		                cat "$stderr_file"
		                echo
		            fi
		        )
		        __test_report+=("$report")
		    fi
		}
		
		# look over test functions
		for __test_func in "${__BGEN_TEST_FUNCS__[@]}"; do
		    __run_test "$__test_func"
		done
		echo
		
		if (("${#__test_failed[@]}")); then
		    printf "\n%bFailed tests:%b\n" "$__COL_TITLE" "$__COL_RESET"
		    for test_func in "${__test_failed[@]}"; do
		        echo "    $test_func"
		    done
		fi
		
		if (("${#__test_report[@]}")); then
		    for test_report in "${__test_report[@]}"; do
		        echo "$test_report"
		    done
		fi
		
		# report on coverage if requested
		BGEN_COVERAGE=1
		if ((BGEN_COVERAGE)); then
		    __bgen_report_coverage
		fi
		
		# exit with error if any test failed
		if (("${#__test_failed[@]}")); then
		    exit 1
		fi
		BGEN_EOF_968302630
    )
# BGEN__INCLUDE_STR_END
    # shellcheck disable=SC2154
    echo "$testlib"
}

# shellcheck disable=SC2034
read_project_meta() {
    local meta_filename="meta.sh"
    local meta_file_path=""

    # shellcheck disable=SC2154
    if [[ -f "$PWD/$meta_filename" ]]; then
        meta_file_path="$PWD/$meta_filename"
    elif [[ -f "$__dir__/$meta_filename" ]]; then
        meta_file_path="$__dir__/$meta_filename"
    fi

    local meta_dir
    if [[ -e "$meta_file_path" ]]; then
        meta_dir=$(dirname "$meta_file_path")

        # shellcheck disable=SC1090
        source "$meta_file_path"
    else
        meta_dir="$PWD"
    fi

    # get project name
    local bgen_project_name
    if [[ "${bgen_project_name:-}" ]]; then
        bgen_project_name="$bgen_project_name"
    else
        bgen_project_name=$(basename "$meta_dir")
    fi
    if is_declared project_name; then
        project_name="$bgen_project_name"
    fi

    # get header file
    if is_declared header_file; then
        header_file="${bgen_header_file:-}"
    fi

    # get entrypoint file
    if is_declared entrypoint_file; then
        entrypoint_file="${bgen_entrypoint_file:-"$meta_dir/src/main.sh"}"
    fi

    # get entrypoint func
    if is_declared entrypoint_func; then
        entrypoint_func="${bgen_entrypoint_func:-}"
    fi

    # get shebang string
    if is_declared shebang_string; then
        shebang_string="${bgen_shebang_string:-"#!/usr/bin/env bash"}"
    fi

    # get output file
    if is_declared output_file; then
        output_file="${bgen_output_file:-"$meta_dir/bin/$bgen_project_name"}"
    fi

    # tests dir
    if is_declared tests_dir; then
        tests_dir="${bgen_tests_dir:-"$meta_dir/tests"}"
    fi

    # imports dir
    if is_declared imports_dir; then
        imports_dir="${bgen_imports_dir:-"$meta_dir/deps"}"
    fi
}

echo_header() {
    if [[ -f "$header_file" ]]; then
        printf '%s\n\n' "$shebang_string"

        process_file "$header_file"
    else
        local default_header
# BGEN__INCLUDE_STR_BEGIN
        default_header=$(
        cat <<-"BGEN_EOF_85549467"
			#!/usr/bin/env bash
			
			# Exit on error. Append "|| true" if you expect an error.
			set -o errexit
			# Exit on error inside any functions or subshells.
			set -o errtrace
			# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
			set -o nounset
			# Catch the error in case mysqldump fails (but gzip succeeds) in $(mysqldump | gzip)
			set -o pipefail
			# Turn on traces, useful for debugging. Set _XTRACE to enable
			[[ "${_XTRACE:-}" ]] && set -o xtrace
			
			# check whether script is source or directly executed
			if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
			    __process__="$__BGEN_PIPE_SOURCE__"
			elif [[ "${BASH_SOURCE+x}" ]]; then
			    __process__="${BASH_SOURCE[0]}"
			else
			    __process__="$0"
			fi
			
			if [[ "${BASH_SOURCE+x}" && "${BASH_SOURCE[0]}" != "${0}" ]]; then
			    __main__= # false
			    # shellcheck disable=SC2154
			    if [[ "${__usage__+x}" ]]; then
			        if [[ "${BASH_SOURCE[1]}" = "${0}" ]]; then
			            __main__=1 # true
			        fi
			
			        __process__="${BASH_SOURCE[1]}"
			    fi
			else
			    # shellcheck disable=SC2034
			    __main__=1 # true
			    [[ "${__usage__+x}" ]] && unset -v __usage__
			fi
			
			# Set magic variables for current file, directory, os, etc.
			__dir__="$(cd "$(dirname "${__process__}")" && pwd)"
			__file__="${__dir__}/$(basename "${__process__}")"
			# shellcheck disable=SC2034,SC2015
			__base__="$(basename "${__file__}" .sh)"
			# shellcheck disable=SC2034,SC2015
			if [[ "${__BGEN_PIPE_SOURCE__:-}" ]]; then
			    __invocation__="${__BGEN_PIPE_SOURCE__}"
			else
			    __invocation__="$(printf %q "${__file__}")"
			fi
			
			# Define the environment variables (and their defaults) that this script depends on
			LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
			NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected
			BGEN_EOF_85549467
        )
# BGEN__INCLUDE_STR_END

        echo "$default_header"
    fi

    # Add some spacing
    printf '\n\n'
}

process_file() {
    local file="$1"

    file=$(realpath "$file")

    local src_dir
    src_dir=$(dirname "$file")
    pushd "$src_dir" >/dev/null || exit

    local found_first_line=
    while IFS= read -r line; do
        # Process source directives that point ot static files
        process_directive "$line" || { check && continue; }

        # Remove first shebang in the file
        if ! [[ "$found_first_line" ]]; then
            process_shebang "$line" || { check && continue; }
        fi

        if [[ ! "$found_first_line" ]]; then
            if ! echo "$line" | grep -E "^[[:space:]]*$" >/dev/null; then
                found_first_line=1
            fi
        fi

        # Otherwise echo the line as is
        echo "$line"
    done <"$file"

    popd >/dev/null || exit
}

echo_entrypoint_call() {
    if [[ "$entrypoint_func" ]]; then
        # shellcheck disable=SC2016
        printf '\n[[ "$__main__" ]] && %s "$@"\n' "$entrypoint_func"
    fi
}

check() {
    local ret="$?"

    if [[ "$ret" == 200 ]]; then
        return 0
    fi

    if [[ "$ret" ]] && ((ret != 0 && ret != 200)); then
        exit "$ret"
    fi

    return 1
}

process_shebang() {
    local line="$1"
    line=$(trim_str "$line")

    if [[ "$line" =~ ^\#\! ]]; then
        found_first_line=1
        echo "# BGEN__SHEBANG_REMOVED"
        return 200
    fi
}

process_directive() {
    local line="$1"

    local trimmed_line
    trimmed_line=$(trim_str "$line")

    if ! [[ "$trimmed_line" =~ ^bgen\: ]]; then
        return 0
    fi

    local indent_size
    indent_size=$(echo "" | awk -v l="$line" -v t="$trimmed_line" '{print index(l, t) - 1}')

    # shellcheck disable=2001
    declare -a "args=( $(echo "$trimmed_line" | sed -e 's/\([`$\(\)]\)/\\\1/g') )"

    if (("${#args[@]}" == 0)); then
        return 0
    fi

    local directive="${args[0]}"
    args=("${args[@]:1}")

    case "$directive" in
    "bgen:import") bgen_import "${args[@]}" ;;
    "bgen:include_str") bgen_include_str "${args[@]}" ;;
    "bgen:"*) bail "unknown bgen directive: $directive" ;;
    *) ;;
    esac
}

find_source_file() {
    local file="${1:-}"

    # If the file exists, return it
    if [[ -f "$file" ]]; then
        echo "$file"
        return
    fi

    # Check if there exists a file with `.sh` appended to it
    if [[ -f "${file}.sh" ]]; then
        echo "${file}.sh"
        return
    fi

    # Check in import directories
    for dir in "${imports_dir[@]}"; do
        if [[ -f "$dir/$file" ]]; then
            echo "$dir/$file"
            return
        fi
        if [[ -f "$dir/${file}.sh" ]]; then
            echo "$dir/${file}.sh"
            return
        fi
    done
}

bgen_import() {
    local file="${1:-}"
    if [[ ! "$file" ]]; then
        bail "bgen:import requires 1 parameter (filename)"
    fi

    # Raise error if file does not exit
    local source_file
    source_file=$(find_source_file "${1:-}")
    if [[ ! -f "$source_file" ]]; then
        bail "bgen import error: cannot import '$file'"
    fi

    local source_realpath
    source_realpath="$(realpath "$source_file")"

    # Don't re-import file if it was already imported
    if ! is_in_array "$source_realpath" "${imported_files[@]-}"; then
        # Mark file as imported
        imported_files+=("$source_realpath")

        # Add a comment indicating where the processing starts
        echo "# BGEN__BEGIN $source_realpath"

        # Do normal file processing
        process_file "$source_file"

        # Add a comment indicating where the processing starts
        echo "# BGEN__END $source_realpath"
    fi

    # Return 200 to tell check() that we've processed something
    return 200
}

bgen_include_str() {
    local variable="${1:-}"
    local file="${2:-}"
    if [[ ! "$variable" || ! "$file" ]]; then
        bail "bgen:include_str requires 2 parameters (variable name and filename)"
    fi

    local indent_size="${indent_size:-0}"
    local tabs=$((indent_size / 4))
    local indent
    indent=$(printf "%${indent_size}s")
    indent_plus=$(printf '\t%.0s' $(seq $((tabs + 1))))

    # Raise error if file does not exit
    if [[ ! -f "$file" ]]; then
        bail "bgen:include_str error: cannot import $file"
    fi

    local heredoc_id="$SRANDOM"
    echo "# BGEN__INCLUDE_STR_BEGIN"
    echo "${indent}${variable}=\$("
    echo "${indent}cat <<-\"BGEN_EOF_${heredoc_id}\""
    while IFS= read -r line; do
        echo "$indent_plus$line"
    done <"$file"
    echo "${indent_plus}BGEN_EOF_${heredoc_id}"
    echo "${indent})"
    echo "# BGEN__INCLUDE_STR_END"

    # Return 200 to tell check() that we've processed something
    return 200
}

is_in_array() {
    local target="$1"
    shift

    for item in "$@"; do
        [[ "$target" == "$item" ]] && return 0
    done

    return 1
}

# Utility function to check if any of the passed variables is not declared
# @param    variable_name...    names of variables to check
is_declared() {
    declare -p "$@" >/dev/null 2>/dev/null
}
# BGEN__END /home/sdrm/projects/bgen/src/build.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/run.sh
# BGEN__SHEBANG_REMOVED


run_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} run"
    bash -c "$(build_project_to_stdout)" "${__base__:-$0} run" "$@"
}

debug_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} debug"
    bash -x -c "$(build_project_to_stdout)" "${__base__:-$0} run" "$@"
}
# BGEN__END /home/sdrm/projects/bgen/src/run.sh
# BGEN__BEGIN /home/sdrm/projects/bgen/src/test.sh
# BGEN__SHEBANG_REMOVED


test_debug_project() {
    export __BGEN_PIPE_SOURCE__="${__base__:-$0} test"
    build_tests_to_stdout "$@"
}

test_project() {
    # TODO: Check awk exists

    local test_code linemap
    test_code="$(build_tests_to_stdout "$@")"
    linemap="$(awk '$0 ~ /^# BGEN__/ {OFS=""; $1=""; $2=$2 " "; print NR " " $0}' <<<"$test_code")"

    export __BGEN_PIPE_SOURCE__="${__base__:-$0} test"
    export __BGEN_LINEMAP__="$linemap"
    bash -c "$test_code" "${__base__:-$0} test" "$@"
}
# BGEN__END /home/sdrm/projects/bgen/src/test.sh

# entrypoint
main() {
    local cmd="${1:-}"

    if [[ "$cmd" == "build" ]]; then
        build_project
        return
    fi

    if [[ "$cmd" == "run" ]]; then
        shift
        run_project "$@"
        return
    fi

    if [[ "$cmd" == "debug" ]]; then
        shift
        debug_project "$@"
        return
    fi

    if [[ "$cmd" == "test" ]]; then
        shift
        test_project "$@"
        return
    fi

    if [[ "$cmd" == "test-debug" ]]; then
        shift
        test_debug_project "$@"
        return
    fi

    build_project_to_stdout
}

[[ "$__main__" ]] && main "$@"
